<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++模板从入门到劝退(0)——左值与右值</title>
    <link href="/2022/05/27/C++%E6%A8%A1%E6%9D%BF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%8A%9D%E9%80%80(0)%E2%80%94%E2%80%94%E5%B7%A6%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC/"/>
    <url>/2022/05/27/C++%E6%A8%A1%E6%9D%BF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%8A%9D%E9%80%80(0)%E2%80%94%E2%80%94%E5%B7%A6%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>谈到C++模板，多少业界大佬无不讳莫如深，而基于模板的元编程更是历来被业界同仁视为黑魔法。模板从诞生至今已有几十年的历史，实际上在经历了C++11标准的革命性洗礼以及后续的缝缝补补后，模板元编程的门槛和抽象程度已经大大降低。纵观历史长河，优秀的C++书籍鳞次栉比，然而涉及到元编程的书籍却屈指可数，那些传世经典的圣经对于模板皆是浅尝辄止。本系列文章将致力于揭开模板元编程的迷雾，通过牺牲一定程度的表述严谨性，按照笔者的归纳方式穿针引线，为痴迷于黑魔法而又始终不得其解的同学打通任督二脉。</p><span id="more"></span><h1 id="左值与右值">左值与右值</h1><p>随着C++11新标准的制定，C++正式进入现代(modern)时代，相对于传统(traditional/old)C++、新标准的推行可谓是革命性的船新版本。而这一变革带来了两种情况：</p><ol type="1"><li>C++神教的新教徒在阅读传统C++代码时会满脸黑人问号：这是个什么方言？</li><li>尚未解锁现代C++的传统C++程序员在接触新标准时会惊呼：还有这种操作？快住手，这根本不是C++！</li></ol><blockquote><p>在《C++ Primer5th》问世时，我曾自信满满淘得一本，自诩有着刷了4遍4th的经验，打开了新世界的大门，然后直接自闭。</p></blockquote><p>当大家聊起C++11时，最先想到的可能就是移动语义，没错，这个移动语义可谓是万恶之源，它一方面解决了C++长久以来的顽疾，另一方面也让原本就复杂的语法规则变本加厉。</p><p>传统C++的顽疾在于基于值语义(ValueSemantics)的冗余拷贝和赋值。所谓值语义，这是很多OO(ObjectOriented)语言中没有的概念，诸如Java,C#等大多数语言，几乎所有的变量都是引用语义(ReferenceSemantics)（它们天生有着GC(GarbageCollector)来管理所有对象的生命周期，开发者无需操心）。而C++并没有做如此现代化的封装，对外呈现的语言生态相当裸露，值语义是指目标对象由源对象拷贝生成，生成的目标对象与源对象毫无关系彼此独立（一些引用语义的编程语言可能只有基础类型是值语义，但同样的它们为了消除违和感对值语义只字不提，而是强调基础类型的特殊性）。对于不了解值语义的C++初学者来说，会想当然的把C++中的引用看成和其他引用语义编程语言中引用的对等概念，这在传统C++中最多是在使用体验上感觉到有些别扭，而到了C++11后，由于对左值引用、右值引用进行了区分，就使得原本理解上的缺失被进一步放大，自然而然得感觉右值引用莫名其妙。</p><blockquote><p>C++对变量生命周期的一种优雅管理方式是RAII，不过不代表RAII能解决所有场景的变量生命期管理需求，更不代表GC没用。</p></blockquote><p>我们以纯OO语言Java为例，如果写这样一段代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s1;<br><br>        System.out.println(System.identityHashCode(s1));<br>        System.out.println(System.identityHashCode(s2));<br>        System.out.println(s1 == s2);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zsh">2060468723<br>2060468723<br>true<br></code></pre></div></td></tr></table></figure><p>可以看到，Java中<code>s1,s2</code>就是引用语义的典范，它们指向的对象是同一个，而在引用语义的编程语言中，这也被称作浅拷贝(ShallowCopy)：在进行赋值、方法传参和返回值时，对于引用类型（非基本类型）一概按引用传递（传址）。</p><blockquote><p>是不是觉着很简单很直观，如果再定义一个<code>String s3 = "hello";</code>，思考下<code>s3</code>和<code>s1</code>是不是同一个对象呢？如果换成<code>String s3 = new String("hello"); String s4 = new String("hello");</code>，<code>s3</code>和<code>s4</code>和<code>s1</code>又是什么关系呢？当然，这是Java体系下的另一个话题了。</p></blockquote><p>再看Python 3:</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">s1 = <span class="hljs-string">&quot;hello&quot;</span><br>s2 = s1<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(s1))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(s2))<br></code></pre></div></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zsh">4341128096<br>4341128096<br></code></pre></div></td></tr></table></figure><p>显然赋值操作是按引用进行传递，<code>s1,s2</code>所指是同一个对象。</p><blockquote><p>我常说python是一门乱七八糟的语言，所谓“动态类型一时爽，代码重构火葬场”。如果定义<code>s3 = "hello"</code>，<code>s3</code>和<code>s1</code>是什么关系呢？如果把"hello"换成"helloworld"呢？当然，这也是Python体系下的另一个话题了。</p></blockquote><blockquote><p>对于Java和Python这类工程/工具语言，没必要过于学究，实际上许多经验丰富的Java/Python程序员对这两个问题也是懵逼的，但这丝毫不影响写出健壮可用的代码，这些问题可能也就面试会被问到。。。但是对于C++来说，凡事都得学究一点，哪怕是经验丰富的C++程序员也常常犯语法错误。</p></blockquote><p>那么在C++中，对于标准库的<code>string</code>来说，我们进行类似的赋值是什么结果呢？</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span>&#123;<br>    string s1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>    string s2 = s1;<br><br>    cout &lt;&lt; &amp;s1 &lt;&lt; endl;<br>    cout &lt;&lt; &amp;s2 &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zsh">0x16d94f678<br>0x16d94f660<br></code></pre></div></td></tr></table></figure><p>可以看到<code>s1,s2</code>的地址并不相同，对于非基础类型，C++中使用相同类型的对象做初始化赋值的语义是去调用该类型的拷贝构造器(copyctor)（C++中初始化赋值和普通的赋值语义并不等同，后者在这种情况下调用的是拷贝赋值操作符(copyassignment))。此外，对于第一行<code>string s1 = "hello";</code>也并没有表面看上去那样简单，<code>std::string</code>并不是基础类型，赋值初始化在C++的语义是调用相应的拷贝构造器，但是由于<code>"hello"</code>这个字符串字面量的类型是<code>const char[6]</code>（有界常量字符数组，而且标准规定字符串字面量是左值），并不能匹配拷贝构造器的参数，因此按照常理来说编译应该报错才对。但另一方面，C++在某些特定场合支持适宜的隐式(implicit)转换，上述代码会先用<code>"hello"</code>隐式的生成一个临时的string对象（这需要<code>std::string</code>有一个接受<code>const char[6]</code>或其退化(decay)类型的构造器），然后再调用拷贝构造器将临时对象复制给<code>s1</code>。</p><p>我们尝试来探讨一下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 如果加explicit关键字，那么String s1 = &quot;hello&quot;;就无法进行隐式转换而报错</span><br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* pstr) : <span class="hljs-built_in">s_</span>(pstr) &#123; cout &lt;&lt; <span class="hljs-string">&quot;call custom ctor&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String&amp; rhs) : <span class="hljs-built_in">s_</span>(rhs.s_) &#123; cout &lt;&lt; <span class="hljs-string">&quot;call copy ctor&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-keyword">private</span>:<br>    string s_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span>&#123;<br>    String s1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>    String s2 = s1;<br><br>    cout &lt;&lt; &amp;s1 &lt;&lt; endl;<br>    cout &lt;&lt; &amp;s2 &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zsh">call custom ctor<br>call copy ctor<br>0x7ff7b4ac1658<br>0x7ff7b4ac1640<br></code></pre></div></td></tr></table></figure><p>显然，运行结果并不符合预期，理论上除了<code>String s2=s1;</code>这一行会调用copyctor以外，<code>String s1 = "hello";</code>也应该调用一次才对，为什么只看到了一次customctor呢？这是因为C++11标准定义了复制省略(CopyElision)技术（诸如<code>String s1 = "hello";</code>的写法其实非常的符合直觉，但是因为值语义的关系，C++却不得不多做一次值拷贝），要求编译器在实现时对这一情景做一次合理的拷贝消除。实际上，在C++11标准化之前各大厂商的编译器就已经为这事买单了（委员会的“懒汉们”永远是亡羊补牢），传统C++的开发者应该也了解诸如RVO(ReturnValue Optimization), NRVO(Named Return ValueOptimization)等技术，而这本质上做的就是特定场合的复制省略（未标准化之前，可以视作语言天然缺陷的遮羞布）。</p><p>如果我们通过编译选项关闭复制省略(-fno-elide-constructors)，重新运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zsh">call custom ctor<br>call copy ctor<br>call copy ctor<br>0x7ff7bf7ba658<br>0x7ff7bf7ba618<br></code></pre></div></td></tr></table></figure><p>C++中基于值语义的拷贝构造和拷贝赋值，可能会导致大对象的冗余拷贝从而引发性能瓶颈。虽然开发者可以通过指针和引用来规避掉部分场景的copy（编译器也十分配合的蒙上遮羞布），但还是有诸多场景无可避免。我曾看过这么一个形象的比喻：要把大象从A冰箱转移到B冰箱需要几步呢？普通青年的做法是3步：打开冰箱A和B的门；把大象从A转移(move)到B；关闭冰箱A和B。2B青年的做法则是：打开冰箱A和B的门；启用量子复制系统在冰箱B克隆出大象；启用射频消融技术将A中大象解体气化。没错，C++曾经就是这个2B青年。</p><p>移动(move)这件事本身很好理解，因为这是一个符合直觉的做法，但是对背着重重历史包袱的C++来说，想要从语言层面理解移动，就需要前置理解这样一个概念：左值(lvalue)和右值(rvalue)。实际上，左值和右值并不是C++11所引入的术语，这两个概念的历史由来可以追溯到编程语言CPL，那么彼时何为左值和右值呢？顾名思义，在赋值操作符('=')左边的就是左值，右边的就是右值，而这也是左值和右值得以命名的历史原因。C语言继承了CPL的分类法，但是弱化了赋值的作用，C语言中左值一开始表示可以被赋值的对象，但由于<code>const</code>的引入，这类对象被修正称作“可更改的左值”，而右值则被视为“值”的同义词，分类上通通都叫作其他(others)（函数和非对象值）。由于const，我们不能再通过表达式值可否修改来判断是否是左值，而是通过是否可寻址（于是坊间流传的一个不严谨的说法就是：左值对应变量的存储位置，右值对应变量的值本身）。</p><blockquote><p>一种说法是ISO C中的lvalue其实是locatorvalue的缩写，算是个美丽的巧合。</p></blockquote><p>传统C++(C++98)对表达式的值分类继承了C的做法，但复辟了右值的称呼，此外，C++98规定函数为左值（因为可以被取地址，在后续的标准演进中函数甚至当家做主成了一等公民，实际上除了函数还有一些其他类似情况的表达式也被视为左值），而C++中的引用可以被绑定在左值之上，但不能绑定到右值（只有const引用可以绑定到右值）。截止C++03，我们把具有标识(identity)的表达式视为左值，没有标识的表达式视为右值。因此，名称、指针、引用都是左值，是命名对象，它们有可以寻址的确定内存地址；字面量、临时对象等视为右值，右值仅在创建它的表达式中可以被访问。函数名称是左值，数组名称是常量左值（只不过大多数表达式中函数名和数组名被自动隐式转换成右值）。右值的生命周期短暂，所以需要左值去捕获它，把右值拷贝(copy)给左值是常规操作。</p><p>然而在C++11之后，为了支撑移动语义引入了右值引用，因此左值和右值的定义发生了很大变化。右值引用可以绑定到右值上来给临时对象续命，而移动语义则把临时对象移动(move)而不是拷贝(copy)到左值对象上。对于左值和右值的分类，标准不得不做一些扩充和修正：</p><ul><li>左值(lvalue): 指定一个对象(object)或函数(function)。<ul><li>如果<code>E</code>是某种类型的指针类型，那么<code>*E</code>就是一个左值表达式，它引用的是<code>E</code>所指向的对象(object)或函数(function)。</li><li>调用一个返回类型为左值引用的函数，其结果是一个左值。</li></ul></li><li>将亡值(xvalue): expiringvalue的缩写，也指定一个对象，这个对象通常是生命周期即将结束的状态，因此它可以被移动。xvalue是某些涉及右值引用的表达式的结果。<ul><li>调用一个返回类型为右值引用的函数，其结果就是一个xvalue。</li></ul></li><li>泛左值(glvalue): lvalue或者是xvalue。</li><li>右值(rvalue):xvalue，临时的对象或子对象，或者是与对象无关的值。</li><li>纯右值(prvalue): 非xvalue的rvalue。<ul><li>调用一个返回类型为非引用类型的函数，其结果就是一个prvalue。</li></ul></li></ul><p><img src="2022-05-30-14-22-25.png" /></p><blockquote><p>大部分初学者都会因为不了解xvalue和prvalue的概念而想当然地把lvalue和rvalue想象成同一层级的概念，而这在学习过程中就会遇到重重困扰，进而对rvalue的概念云里雾里。实际上rvalue是个混合分类。</p></blockquote><p>自此，表达式的值分类不仅考虑了标识(identify)，还考虑了可移动性(movability)。我们按照标准做一下归纳：</p><ul><li>左值(lvalue): 具有标识，不可移动。</li><li>将亡值(xvalue): 具有标识，可以移动。</li><li>纯右值(prvalue): 没有标识，可以移动。</li><li>泛左值(glvalue): 具有标识</li><li>右值(rvalue): 可以移动</li></ul><p>这样一分类，是不是有种恍然大悟的感觉~</p><p>那么再看看三种基本值类型都对应哪些表达式呢？这里参考reference手册并裁剪掉一些cornercase：</p><ul><li>左值(lvalue):<ul><li>变量名、函数名、数据成员<ul><li>即使变量类型是右值引用，变量本身依然是左值(这不是特例，是正统的语法规则)</li><li><code>std::getline</code></li><li><code>std::cin</code>, <code>std::endl</code></li></ul></li><li>返回类型为左值引用的函数调用或操作符重载或类型转换<ul><li><code>std::getline(std::cin, str)</code></li><li><code>std::cout &lt;&lt; 1</code>, <code>str1 = str2</code>,<code>++it</code></li><li><code>static_cast&lt;int&amp;&gt;(val)</code></li></ul></li><li>返回类型为函数右值引用的函数调用或操作符重载或类型转换<ul><li><code>static_cast&lt;void (&amp;&amp;)(int)&gt;(x)</code></li></ul></li><li>内建(built-in)的赋值与复合赋值表达式<ul><li><code>a=b</code></li><li><code>a+=b</code>,<code>a*=b</code></li></ul></li><li>内建(built-in)的前缀自增、自减<ul><li><code>a++</code></li><li><code>a--</code></li></ul></li><li>内建(built-in)的解引用表达式<ul><li><code>*p</code></li></ul></li><li>内建(built-in)的下标操作符表达式<ul><li><code>a[n]</code>, <code>p[n]</code></li></ul></li><li>对象成员访问，内建(built-int)的指针成员访问<ul><li><code>a.m</code>(<code>m</code>不能是枚举成员，也不能是非静态成员函数）</li><li><code>t.m</code>(<code>t</code>为右值且<code>m</code>为非静态数据成员)</li><li><code>p-&gt;m</code>(<code>m</code>不能是成员枚举值，也不能是非静态成员函数)</li></ul></li><li>对象的成员指针访问，内建(built-in)的指针的成员指针访问（成员指针的指针本质上是偏移，和普通的指针不太一样，导致这两个东西非常的拗口和别扭）<ul><li><code>a.*mp</code>(<code>a</code>是左值，<code>mp</code>是数据成员指针)</li><li><code>p-&gt;*mp</code>(<code>mp</code>是数据成员指针)</li></ul></li><li>右端为左值的逗号表达式<ul><li><code>a, b</code>(<code>b</code>是左值)</li></ul></li><li>二、三操作数为特定值的三元运算符</li><li>字符串字面量(String Literal)<ul><li><code>"hello"</code></li></ul></li></ul></li><li>纯右值(prvalue):<ul><li>字面量<ul><li><code>42</code></li><li><code>'a'</code></li><li><code>true</code></li><li><code>nullptr</code></li></ul></li><li>返回类型为非引用的函数调用或操作符重载或类型转换<ul><li><code>str.substr(1, 2)</code></li><li><code>str1 + str2</code></li><li><code>it++</code></li><li><code>static_cast&lt;double&gt;(x)</code>,<code>std::string&#123;&#125;</code>, <code>(int)42</code></li></ul></li><li>内建(built-in)的后缀自增、自减表达式<ul><li><code>a++</code></li><li><code>b--</code></li></ul></li><li>内建(built-in)的算数、逻辑、比较、取地址表达式<ul><li><code>a + b</code>, <code>a % b</code>, <code>a &amp; b</code>,<code>a &lt;&lt; b</code></li><li><code>a &amp;&amp; b</code>, <code>a || b</code>,<code>!a</code></li><li><code>a &lt; b</code>, <code>a == b</code>,<code>a &gt;= b</code></li><li><code>&amp;a</code></li></ul></li><li>对象成员访问，内建(built-in)的指针成员访问<ul><li><code>a.m</code>(<code>m</code>是成员枚举值或非静态成员函数)</li><li><code>p-&gt;m</code>(<code>m</code>是成员枚举值或非静态成员函数)</li></ul></li><li>对象的成员指针访问，内建(built-in)的指针的成员指针访问<ul><li><code>a.*mp</code>(<code>mp</code>是成员函数指针)</li><li><code>p-&gt;*mp</code>(<code>mp</code>是成员函数指针)</li></ul></li><li>右端为右值的逗号表达式</li><li>二、三操作数为特定值的三元表达式</li><li><code>this</code>指针</li><li>枚举值</li><li>lambda表达式<ul><li><code>[](int x)&#123; return x * x; &#125;</code></li></ul></li></ul></li><li>将亡值(xvalue):<ul><li>返回类型为右值引用的函数调用或操作符重载或类型转换<ul><li><code>std::move(x)</code></li><li><code>static_cast&lt;char&amp;&amp;&gt;(x)</code></li></ul></li><li>对象成员访问<ul><li><code>t.m</code>(<code>t</code>是右值且<code>m</code>是非静态非引用数据成员)</li></ul></li><li>对象的成员指针访问<ul><li><code>t.*mp</code>(<code>t</code>是右值且<code>mp</code>是数据成员指针)</li></ul></li><li>二、三操作数为特定值的三元表达式</li></ul></li></ul><blockquote><p>三元表达式目前的分类比较复杂，详见https://en.cppreference.com/w/cpp/language/operator_other#Conditional_operator</p></blockquote><p>这里的分类因C++历史的演进而变得非常复杂，初学者没必要全盘记住，实际上日后了解了更多的细节后，会发现这里的分类其实是非常直观的。至此，如果你能看到这里，那么恭喜你，基础的内容你已经掌握了，下一讲，我们谈谈右值引用和移动语义。</p>]]></content>
    
    
    <categories>
      
      <category>program-language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>cpp-templates</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(十二)——图和网络</title>
    <link href="/2022/05/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%BA%8C)%E2%80%94%E2%80%94%E5%9B%BE%E5%92%8C%E7%BD%91%E7%BB%9C/"/>
    <url>/2022/05/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%BA%8C)%E2%80%94%E2%80%94%E5%9B%BE%E5%92%8C%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<p>这一讲作为第一部分的最后一节内容，主要着重于描述线性代数的应用。</p><h1 id="图和网络">图和网络</h1><h2 id="有向图">有向图</h2><p>给定一个有向图：4节点，5条边 <imgsrc="2022-05-14-16-56-35.png" /></p><p>可以用如下方式来抽象描述：。 <span class="math display">\[\begin{array}{c | c c c c}&amp; node_1 &amp; node_2 &amp; node_3 &amp; node_4\\ \hlineedge_1 &amp; -1     &amp; 1      &amp; 0      &amp; 0\\ edge_2 &amp; 0      &amp; -1     &amp; 1      &amp; 0\\ edge_3 &amp; -1     &amp; 0      &amp; 1      &amp; 0\\ edge_4 &amp; -1     &amp; 0      &amp; 0      &amp; 1\\ edge_5 &amp; 0      &amp; 0      &amp; -1     &amp; 1\end{array}\]</span></p><p>写成<span class="math inline">\(5\times 4\)</span>矩阵来表示如下：<span class="math display">\[A=\begin{bmatrix}-1 &amp; 1 &amp; 0 &amp; 0\\ 0 &amp; -1 &amp; 1 &amp; 0\\ -1 &amp; 0 &amp; 1 &amp; 0\\ -1 &amp; 0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; -1 &amp; 1\end{bmatrix}\]</span></p><p>该矩阵叫做关联矩阵，其中每一列代表一个节点，每一行代表一条边（正负代表方向）。</p><p>通过观察前三行，可以看出这三个行向量线性相关，而实际上，它的物理意义就是这三个向量（三条边）可以形成回路。关联矩阵一般是稀疏阵，因为每一行只有两个非零元素。</p><h3 id="a的零空间"><span class="math inline">\(A\)</span>的零空间</h3><p>矩阵<span class="math inline">\(A\)</span>的零空间可以通过解<spanclass="math inline">\(Ax=0\)</span>来得到，有： <spanclass="math display">\[Ax=\begin{bmatrix}-1 &amp; 1 &amp; 0 &amp; 0\\ 0 &amp; -1 &amp; 1 &amp; 0\\ -1 &amp; 0 &amp; 1 &amp; 0\\ -1 &amp; 0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; -1 &amp; 1\end{bmatrix}\begin{bmatrix}x_1\\ x_2\\ x_3\\ x_4\end{bmatrix}=0\]</span></p><p>展开得： <span class="math display">\[\begin{bmatrix}x_2-x_1\\ x_3-x_2\\ x_3-x_1\\ x_4-x_1\\ x_4-x_3\end{bmatrix}=\begin{bmatrix}0\\ 0\\ 0\\ 0\\ 0\end{bmatrix}\]</span></p><p>引入矩阵的实际意义：将<spanclass="math inline">\(x=\begin{bmatrix}x_1 &amp; x_2 &amp; x_3 &amp;x_4\end{bmatrix}\)</span>视为各节点电势，则式子中的诸如<spanclass="math inline">\(x_2-x_1\)</span>的元素，可以看做该边上的电势差。容易看出其中一个解<spanclass="math inline">\(x=\begin{bmatrix}1\\ 1\\ 1\\1\end{bmatrix}\)</span>，即等电势情况，此时电势差为<spanclass="math inline">\(0\)</span>。化简<spanclass="math inline">\(A\)</span>易得<spanclass="math inline">\(rank(A)=3\)</span>，所以其零空间维数应为<spanclass="math inline">\(n-r=4-3=1\)</span>，即<spanclass="math inline">\(\begin{bmatrix}1\\1\\1\\1\end{bmatrix}\)</span>就是其零空间的一组基。</p><p>Q: 那么以电势为例，零空间的物理意义是什么呢？ A:电势差和电流的形成之间有着直接关系，<spanclass="math inline">\(b=0\)</span>说明我们求解的情况是各个边上都没有电流（或者说电势差）的情况，而我们最后所得到的解就意味着，当各点电势相等时，边上电流（电势差）为零，符合我们的常识。而这就是零空间的物理意义。</p><h3 id="a的左零空间"><spanclass="math inline">\(A\)</span>的左零空间</h3><p><span class="math inline">\(A\)</span>的左零空间是什么呢？或者说<spanclass="math inline">\(A^T\)</span>的零空间是什么呢？即求<spanclass="math inline">\(A^Ty=0\)</span>： <span class="math display">\[A^Ty=0=\begin{bmatrix}-1 &amp; 0 &amp; -1 &amp; -1 &amp; 0\\ 1 &amp; -1 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 1 &amp; 0 &amp; -1\\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1\end{bmatrix}\begin{bmatrix}y_1\\ y_2\\ y_3\\ y_4\\ y_5\end{bmatrix}=\begin{bmatrix}-y_1-y_3-y_4\\ y_1-y_2\\ y_2+y_3-y_5\\ y_4+y_5\end{bmatrix}=\begin{bmatrix}0\\ 0\\ 0\\ 0\end{bmatrix}\]</span></p><p>接着说上文提到的的电势差，引入<spanclass="math inline">\(y\)</span>的实际物理意义：即各边上的电流。电流和电势差的关系服从欧姆定律：边上的电流值是边上电势差的倍数，这个倍速就是边的电导，亦即电阻的倒数，通常我们把这个常数视为一个系数矩阵记为<spanclass="math inline">\(C\)</span>。于是，矩阵<spanclass="math inline">\(C\)</span>就将电势差与电流联系了起来： <spanclass="math display">\[y=\begin{bmatrix}y_1\\ y_2\\ y_3\\ y_4\\ y_5\end{bmatrix}=C\begin{bmatrix}x_2-x_1\\ x_3-x_2\\ x_3-x_1\\ x_4-x_1\\ x_4-x_3\end{bmatrix}\]</span></p><p>实际上<spanclass="math inline">\(A^Ty=0\)</span>阐释的就是“基尔霍夫电流定律”（KCL），基尔霍夫电流定律是一个平衡方程，守恒定律，它说明了流入等于流出，电荷在结点上不会积累。</p><p>对于<spanclass="math inline">\(A^T\)</span>，有上文得出其零空间的维数是<spanclass="math inline">\(2\)</span>，则零空间的基应该有两个向量。假设<spanclass="math inline">\(y_1=1\)</span>，也就是令<spanclass="math inline">\(1\)</span>安培的电流在边<spanclass="math inline">\(1\)</span>上流动，由图看出<spanclass="math inline">\(y_2\)</span>也应该为<spanclass="math inline">\(1\)</span>，再令<spanclass="math inline">\(y_3=-1\)</span>，也就是让<spanclass="math inline">\(1\)</span>安培的电流流回节点<spanclass="math inline">\(1\)</span>，得出<spanclass="math inline">\(y_4=y_5=0\)</span>；</p><p>得到一个符合KCL的向量<span class="math inline">\(\begin{bmatrix}1\\1\\ -1\\ 0\\0\end{bmatrix}\)</span>，代回方程组发现此向量即为一个解，这个解发生在节点<spanclass="math inline">\(1,2,3\)</span>组成的回路中，该解即为零空间的一个基。</p><p>如法炮制可以得出另一个基向量：<spanclass="math inline">\(\begin{bmatrix}0\\ 0\\ 1\\ -1\\1\end{bmatrix}\)</span>，这实际上是节点<spanclass="math inline">\(1,3,4\)</span>构成的回路。</p><p>如此，我们得到<spanclass="math inline">\(N(A^T)\)</span>的一组基为<spanclass="math inline">\(\begin{bmatrix}1\\ 1\\ -1\\ 0\\0\end{bmatrix}\quad\begin{bmatrix}0\\ 0\\ 1\\ -1\\1\end{bmatrix}\)</span>。</p><blockquote><p>节点<spanclass="math inline">\(1,2,3,4\)</span>构成的大回路实际上是两个基向量回路的叠加。</p></blockquote><h3 id="a的行空间"><span class="math inline">\(A\)</span>的行空间</h3><p>亦即<spanclass="math inline">\(A^T\)</span>的列空间，方便起见我们直接计算<spanclass="math inline">\(A^T\)</span>的列空间： <spanclass="math display">\[A^T=\begin{bmatrix}-1 &amp; 0 &amp; -1 &amp; -1 &amp; 0\\ 1 &amp; -1 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 1 &amp; 0 &amp; -1\\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1\end{bmatrix}\]</span></p><p>显然，<span class="math inline">\(A^T\)</span>的主列为第<spanclass="math inline">\(1,2,4\)</span>列，对应在图中就是边<spanclass="math inline">\(1,2,4\)</span>，可以发现这三条边没有组成回路（<strong>换句话说，线性无关等价于没有回路</strong>）。由<spanclass="math inline">\(4\)</span>个节点与<spanclass="math inline">\(3\)</span>条边组成的图没有回路，就表明<spanclass="math inline">\(A^T\)</span>的对应列向量线性无关，也就是（<spanclass="math inline">\(nodes-1\)</span>）条边线性无关。</p><blockquote><p>没有回路的图叫作树。</p></blockquote><p>再看左零空间的维数公式：<span class="math inline">\(dimN(A^T)=m-r\)</span>，左零空间的维数就是相互无关的回路的数量，于是得到<spanclass="math inline">\(loops=edges-(nodes-1)\)</span>，整理得： <spanclass="math display">\[nodes-edges+loops=1\]</span></p><p>此等式对任何图均有效，任何图都有此拓扑性质，这就是著名的欧拉公式：<span class="math display">\[节点数-边数+最小回路数=1\]</span></p>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(十一)——矩阵空间、秩1矩阵和小世界图</title>
    <link href="/2022/05/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%B8%80)%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E7%A9%BA%E9%97%B4%E3%80%81%E7%A7%A91%E7%9F%A9%E9%98%B5%E5%92%8C%E5%B0%8F%E4%B8%96%E7%95%8C%E5%9B%BE/"/>
    <url>/2022/05/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%B8%80)%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E7%A9%BA%E9%97%B4%E3%80%81%E7%A7%A91%E7%9F%A9%E9%98%B5%E5%92%8C%E5%B0%8F%E4%B8%96%E7%95%8C%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p>本讲是上一讲的扩展内容，共分为3部分，第一部分延续上一讲介绍了矩阵空间的特性并延展到微分方程的例子，第二部分介绍了一个特殊的秩1矩阵，第三部分介绍了图的概念以及图与矩阵的关系。</p><span id="more"></span><h1 id="矩阵空间秩1矩阵和小世界图">矩阵空间、秩1矩阵和小世界图</h1><h2 id="矩阵空间">矩阵空间</h2><p>话接上一讲，以<span class="math inline">\(3\times3\)</span>矩阵为例，矩阵空间记为<spanclass="math inline">\(M\)</span>，则其一组基为： <spanclass="math display">\[\begin{bmatrix}1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 1 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\end{bmatrix}\]</span></p><p>另一方面，对称阵<spanclass="math inline">\(S\)</span>的基也非常容易找到： <spanclass="math display">\[\begin{bmatrix}1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\end{bmatrix}\begin{bmatrix}0 &amp; 1 &amp; 0\\ 1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; 0\\ 1 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\\ 0 &amp; 1 &amp; 0\end{bmatrix}\]</span></p><p>上三角阵<span class="math inline">\(U\)</span>的基： <spanclass="math display">\[\begin{bmatrix}1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\end{bmatrix}\]</span></p><p>对角矩阵<span class="math inline">\(D\)</span>的基： <spanclass="math display">\[\begin{bmatrix}1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\end{bmatrix}\]</span></p><p>因此，有：<span class="math inline">\(dim M=9\)</span>，<spanclass="math inline">\(dim S=6\)</span>，<span class="math inline">\(dimU=6\)</span>，<span class="math inline">\(dim D=3\)</span>。</p><ul><li>求和（sum）：<span class="math inline">\(S+U=M,dim(S+U)=9\)</span>；</li><li>求交（intersect）：<span class="math inline">\(S \cap U=D, dim(S\cap U)=3\)</span>；</li></ul><p>可以看出：<span class="math inline">\(dim S + dim U=12=dim(S+U) +dim(S \cap U)\)</span>。</p><blockquote><p><span class="math inline">\(S+U\)</span>可以看出就是<spanclass="math inline">\(M\)</span>，但是要注意<spanclass="math inline">\(S+U\)</span>并不是<span class="math inline">\(S\cup U\)</span>，后者只包含了<spanclass="math inline">\(S\)</span>和<spanclass="math inline">\(U\)</span>，而前者包含的是<spanclass="math inline">\(S\)</span>中元素和<spanclass="math inline">\(U\)</span>中元素的线性组合，这样的线性组合显然包含了<spanclass="math inline">\(S\)</span>和<spanclass="math inline">\(U\)</span>，也即 <span class="math inline">\((S\cup U) \subseteq (S + U)\)</span>。</p></blockquote><p>空间内元素还可以进一步扩展，不仅限于矩阵或向量，比如还可以是微分方程的解。</p><h2 id="微分方程">微分方程</h2><p>求解：<spanclass="math inline">\(\frac{d^2y}{dx^2}+y=0\)</span>，即<spanclass="math inline">\(y&#39;&#39;+y=0\)</span></p><p>方程的解有：<span class="math inline">\(y=\cos{x}, \quad y=\sin{x},\quad y=e^{ix}, \quad y=e^{-ix}\)</span>等等（<spanclass="math inline">\(e^{ix}=\cos{x}+i\sin{x}, \quade^{-ix}=\cos{x}-i\sin{x}\)</span>）</p><p>只考虑实数范围，该方程的通解为：<span class="math inline">\(y=c_1\cos{x} + c_2 \sin{x}\)</span>。</p><p>所以，该方程的零空间的一组基为<span class="math inline">\(\cos{x},\sin{x}\)</span>，零空间的维数为<spanclass="math inline">\(2\)</span>。同理，如果考虑复数范围，那么<spanclass="math inline">\(e^{ix}, e^{-ix}\)</span>也可以作为另一组基。</p><p>该微分方程的所有解的集合实际上就可以看做是一个“向量空间”，或者应该叫“解空间”，他们满足加法和数乘的封闭性。</p><h2 id="秩1矩阵">秩1矩阵</h2><p>秩<span class="math inline">\(1\)</span>矩阵也即秩为<spanclass="math inline">\(1\)</span>的矩阵。所有的秩<spanclass="math inline">\(1\)</span>矩阵都可以表示成一列乘以一行（<spanclass="math inline">\(A=UV^T\)</span>）的形式，如： <spanclass="math display">\[A=\begin{bmatrix}1&amp;4&amp;5\\ 2&amp;8&amp;10\end{bmatrix}=\begin{bmatrix}1\\ 2\end{bmatrix}\begin{bmatrix}1&amp;4&amp;5\end{bmatrix}\]</span></p><p>其中<span class="math inline">\(dimC(A)=1=dimC(A^T)\)</span>，<spanclass="math inline">\(U, V\)</span>均为列向量。</p><p>秩<spanclass="math inline">\(1\)</span>矩阵类似积木，任何矩阵都是有秩<spanclass="math inline">\(1\)</span>矩阵搭建而成的，如对于一个<spanclass="math inline">\(5 \times 17\)</span>秩为<spanclass="math inline">\(4\)</span>的矩阵，只需要<spanclass="math inline">\(4\)</span>个秩一矩阵就可以组合出来，具体过程类似于我们在第3讲中提到的矩阵乘法中的“列乘行”形式。</p><p>另外，矩阵的加法存在这样的性质：<span class="math inline">\(rank(A+B)\lerank(A)+rank(B)\)</span>。这意味着：对于同样规模的同秩矩阵所组成的集合，其加法是不封闭的。两个<spanclass="math inline">\(5\times 6\)</span>的秩为<spanclass="math inline">\(4\)</span>矩阵相加，结果的秩可能大于<spanclass="math inline">\(4\)</span>。</p><h2 id="示例">示例</h2><p>在<span class="math inline">\(\mathbb{R}^4\)</span>空间中有向量<spanclass="math inline">\(v=\begin{bmatrix}v_1\\ v_2\\ v_3\\v_4\end{bmatrix}\)</span>，取<spanclass="math inline">\(\mathbb{R}^4\)</span>中满足<spanclass="math inline">\(v_1+v_2+v_3+v_4=0\)</span>的所有向量组成一个向量空间<spanclass="math inline">\(S\)</span>，则<spanclass="math inline">\(S\)</span>是一个向量子空间。易看出，不论是使用系数乘以该向量，或是用两个满足条件的向量相加，其结果仍然落在分量和为零的向量空间中。</p><p><strong><span class="math inline">\(S\)</span>的维数</strong>从另一个角度看，<spanclass="math inline">\(v_1+v_2+v_3+v_4=0\)</span>等价于: <spanclass="math display">\[\begin{bmatrix}1&amp;1&amp;1&amp;1\end{bmatrix}\begin{bmatrix}v_1\\v_2\\v_3\\v_4\end{bmatrix}=0\]</span></p><p>则<span class="math inline">\(S\)</span>就是<spanclass="math inline">\(A=\begin{bmatrix}1&amp;1&amp;1&amp;1\end{bmatrix}\)</span>的零空间。<spanclass="math inline">\(rank(A)=1\)</span>，则对其零空间有<spanclass="math inline">\(rank(N(A))=n-r=3=dim N(A)\)</span>，则<spanclass="math inline">\(S\)</span>的维数是<spanclass="math inline">\(3\)</span>。</p><p>矩阵<span class="math inline">\(A\)</span>的四个基本子空间： -行空间：<span class="math inline">\(dimC(A^T)=1\)</span>，其中的一组基是<spanclass="math inline">\(\begin{bmatrix}1\\ 1\\ 1\\1\end{bmatrix}\)</span>； - 零空间：<span class="math inline">\(dimN(A)=3\)</span>，其中的一组基是<spanclass="math inline">\(\begin{bmatrix}-1\\ 1\\ 0\\0\end{bmatrix}\begin{bmatrix}-1\\ 0\\ 1\\0\end{bmatrix}\begin{bmatrix}-1\\ 0\\ 0\\ 1\end{bmatrix}\)</span> -列空间：<span class="math inline">\(dimC(A)=1\)</span>，其中一组基是<spanclass="math inline">\(\begin{bmatrix}1\end{bmatrix}\)</span>，可以看出列空间就是整个<spanclass="math inline">\(\mathbb{R}^1\)</span>空间。 - 左零空间：<spanclass="math inline">\(dim N(A^T)=0\)</span>，因为<spanclass="math inline">\(A\)</span>转置后没有非零的<spanclass="math inline">\(v\)</span>可以使<spanclass="math inline">\(Av=0\)</span>成立，就是<spanclass="math inline">\(\begin{bmatrix}0\end{bmatrix}\)</span>。</p><p>综上，<span class="math inline">\(dim C(A^T)+dim N(A)=4=n, dimC(A)+dim N(A^T)=1=m\)</span></p><h2 id="小世界图">小世界图</h2><p><strong>图是点和边的集合，边连通各个点。</strong></p><p><img src="2022-05-14-16-41-56.png" /></p><p>假设，每个人是图中的一个节点，如果两个人为朋友关系，则在这两个人的节点间添加一条边，通常来说，从一个节点到另一个节点只需要不超过<spanclass="math inline">\(6\)</span>步（即六条边）即可到达，这就是大名鼎鼎的“<strong>六度分割理论</strong>”。</p><p>图与矩阵有怎样的联系呢？下一讲会进行阐述。</p>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(十)——四个基本子空间</title>
    <link href="/2022/05/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81)%E2%80%94%E2%80%94%E5%9B%9B%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%AD%90%E7%A9%BA%E9%97%B4/"/>
    <url>/2022/05/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%8D%81)%E2%80%94%E2%80%94%E5%9B%9B%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%AD%90%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p>这一讲系统地讲解了矩阵的四个基本子空间：行空间，列空间，零空间和左零空间。他们关系密切且极其重要，对于每个子空间，我们探索了基和维数并高度概括了其背后的关联性。</p><span id="more"></span><h1 id="四个基本子空间">四个基本子空间</h1><p>现有<span class="math inline">\(m \times n\)</span>矩阵<spanclass="math inline">\(A\)</span>，已知<spanclass="math inline">\(rank(A)=r, r\le min(n,m)\)</span>，则有： *行空间<span class="math inline">\(C(A^T) \in \mathbb{R}^n, dimC(A^T)=r\)</span>。 * 零空间<span class="math inline">\(N(A) \in\mathbb{R}^n, dim N(A)=n-r\)</span>。 * 列空间<spanclass="math inline">\(C(A) \in \mathbb{R}^m, dim C(A)=r\)</span>。 *左零空间<span class="math inline">\(N(A^T) \in \mathbb{R}^m, dimN(A^T)=m-r\)</span>。</p><p>根据上一讲的内容，列空间和零空间的维数和基我们都已了然于胸，而实际上，行空间和左零空间也如出一辙，不过就是把<spanclass="math inline">\(A\)</span>做了转置以后，如法炮制得到的列空间和零空间。</p><blockquote><p>列空间的基：主元所在列的所有向量；零空间的基：所有线性无关的特解。</p></blockquote><p>事实上，除了先转置再如法炮制的法子以外，对于行空间和左零空间，我们还有更便捷的求解方法。</p><h2 id="行空间">行空间</h2>假如我们换个角度思考，直接来看<spanclass="math inline">\(A\)</span>的行向量组，消元得到： $ A=<span class="math display">\[\begin{bmatrix}1 &amp; 2 &amp; 3 &amp; 1\\ 1 &amp; 1 &amp; 2 &amp; 1\\ 1 &amp; 2 &amp; 3 &amp; 1\end{bmatrix}\underrightarrow{消元}\begin{bmatrix}1 &amp; 0 &amp; 1 &amp; 1\\ 0 &amp; 1 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 0\end{bmatrix}\]</span><p>=R $</p><p>消元的本质是做行变换，此时A的列空间发生变化（<spanclass="math inline">\(C(R) \neqC(A)\)</span>），但却并不影响行空间，所以可以在<spanclass="math inline">\(R\)</span>中看出前两行就是行空间的一组基。所以，可以得出无论对于矩阵<spanclass="math inline">\(A\)</span>还是<spanclass="math inline">\(R\)</span>，其行空间的一组基，可以由<spanclass="math inline">\(R\)</span>矩阵的前<spanclass="math inline">\(r\)</span>行向量组成。</p><blockquote><p>这里的<spanclass="math inline">\(R\)</span>就是第七讲提到的简化行阶梯形式。</p></blockquote><h2 id="左零空间">左零空间</h2><p>对于左零空间，有<span class="math inline">\(A^Ty=0 \rightarrow(A^Ty)^T=0^T\rightarrow y^TA=0^T\)</span>，因此得名。</p><p>采用Gauss-Jordan消元，将增广矩阵<spanclass="math inline">\(\left[\begin{array}{c|c}A_{m \times n} &amp; I_{m\times m}\end{array}\right]\)</span>中<spanclass="math inline">\(A\)</span>的部分划为简化行阶梯形式<spanclass="math inline">\(\left[\begin{array}{c|c}R_{m \times n} &amp; E_{m\times m}\end{array}\right]\)</span>，此时矩阵<spanclass="math inline">\(E\)</span>会将所有的行变换记录下来。</p><p>则<span class="math inline">\(EA=R\)</span>，而在前几讲中，有当<spanclass="math inline">\(A&#39;\)</span>是<spanclass="math inline">\(m\)</span>阶可逆方阵时，<spanclass="math inline">\(R&#39;\)</span>即是<spanclass="math inline">\(I\)</span>，所以<spanclass="math inline">\(E\)</span>就是<spanclass="math inline">\(A^{-1}\)</span>。</p><p>本例中 <span class="math display">\[\left[\begin{array}{c|c}A_{m \times n} &amp; I_{m \timesm}\end{array}\right]=\left[\begin{array}{c c c c|c c c}1 &amp; 2 &amp; 3 &amp; 1 &amp; 1 &amp; 0 &amp; 0\\ 1 &amp; 1 &amp; 2 &amp; 1 &amp; 0 &amp; 1 &amp; 0\\ 1 &amp; 2 &amp; 3 &amp; 1 &amp; 0 &amp; 0 &amp; 1\end{array}\right]\underrightarrow{消元}\left[\begin{array}{c c c c|c c c}1 &amp; 0 &amp; 1 &amp; 1 &amp; -1 &amp; 2 &amp; 0\\ 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; -1 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; 1\end{array}\right]=\left[\begin{array}{c|c}R_{m \times n} &amp; E_{m \timesm}\end{array}\right]\]</span></p><p>则 <span class="math display">\[EA=\begin{bmatrix}-1 &amp; 2  &amp; 0\\ 1  &amp; -1 &amp; 0\\ -1 &amp; 0  &amp; 1\end{bmatrix}\cdot\begin{bmatrix}1 &amp; 2 &amp; 3 &amp; 1\\ 1 &amp; 1 &amp; 2 &amp; 1\\ 1 &amp; 2 &amp; 3 &amp; 1\end{bmatrix}=\begin{bmatrix}1 &amp; 0 &amp; 1 &amp; 1\\ 0 &amp; 1 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 0\end{bmatrix}=R\]</span></p><p>很明显，式中<span class="math inline">\(E\)</span>的最后一行对<spanclass="math inline">\(A\)</span>的行做线性组合后，得到<spanclass="math inline">\(R\)</span>的最后一行，即<spanclass="math inline">\(0\)</span>向量，也就是<spanclass="math inline">\(y^TA=0^T\)</span>。另一方面，<spanclass="math inline">\(E\)</span>的第三行对应的行向量就是矩阵<spanclass="math inline">\(A\)</span>的左零空间的基。</p><h2 id="矩阵空间">矩阵空间</h2><p>不只是向量可以构建出空间，万物皆可构造出空间，只要满足加法和数乘的封闭性即可。</p><p>举个例子，矩阵可以同向量一样，做求和、数乘。那么什么样的矩阵构成的空间满足封闭性呢？比如，设所有<span class="math inline">\(3 \times3\)</span>矩阵组成的矩阵空间为<spanclass="math inline">\(M\)</span>。则上三角矩阵、对称矩阵、对角矩阵（前两者的交集）都可以构成矩阵空间。</p>观察一下对角矩阵，如果取： $<span class="math display">\[\begin{bmatrix}1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix} \quad\begin{bmatrix}1 &amp; 0 &amp; 0\\ 0 &amp; 3 &amp; 0\\ 0 &amp; 0 &amp; 0\end{bmatrix} \quad\begin{bmatrix}0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 7\end{bmatrix}\]</span><p>$</p><p>可以发现，任何三阶对角矩阵均可用这三个矩阵的线性组合生成，因此，他们生成了三阶对角矩阵空间，即这三个矩阵是三阶对角矩阵空间的一组基。</p>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(九)——线性相关性、基和维数</title>
    <link href="/2022/05/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%B9%9D)%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%80%A7%E3%80%81%E5%9F%BA%E5%92%8C%E7%BB%B4%E6%95%B0/"/>
    <url>/2022/05/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%B9%9D)%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%80%A7%E3%80%81%E5%9F%BA%E5%92%8C%E7%BB%B4%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>这一讲对向量组的线性相关性、线性无关性做了进一步的阐释，之后引出向量空间中基和维数的概念。</p><span id="more"></span><h1 id="线性相关性基和维数">线性相关性、基和维数</h1><h2 id="线性相关线性无关">线性相关、线性无关</h2><p>所谓的线性相关和线性无关是用于描述向量组中所有向量的关系，根据此前所掌握的知识，我们知道：以<spanclass="math inline">\(A\)</span>中列向量组为例，如果不存在零解以外的零向量的线性组合，那么列向量组就是线性无关的，否则就是线性相关的。</p><p>进一步，我们可以知道，如果向量组包含一个零向量，那么该向量组一定是线性相关的（因为零向量的可以取任意分量）。</p><p>总结： 给定<span class="math inline">\(v_1,\ v_2,\ \cdots,\v_n\)</span>是<span class="math inline">\(m\times n\)</span>矩阵<spanclass="math inline">\(A\)</span>的列向量： - 如果<spanclass="math inline">\(A\)</span>零空间中有且仅有<spanclass="math inline">\(0\)</span>向量，则各向量线性无关，此时有：<spanclass="math inline">\(rank(A)=n\)</span>。 - 如果存在非零向量<spanclass="math inline">\(c\)</span>使得<spanclass="math inline">\(Ac=0\)</span>，则存在线性相关向量，此时有：<spanclass="math inline">\(rank(A)\lt n\)</span>。</p><p>用此前课程所掌握的知识来描述，前者就是列满秩，此时没有自由列，也就没有自由变量，因此零空间只有零向量，因而向量组线性无关；后者则存在自由列，零空间除了零向量以外还有其他向量，因而向量组线性相关。</p><p>至此，向量组的线性相关性与矩阵的零空间就联系起来了。</p><h2 id="基和维数">基和维数</h2><p>对于线性无关的情况，我们实际上关心的正是这一组“最小的”向量组：它们线性无关，且能生成相应大小的向量空间。而这恰恰就是“基”的概念。</p><p>向量空间的基本质上就是一个向量组，我们之所以额外地称这些向量组为基是因为其既有两个性质：- 向量组中的向量线性无关 -向量组中的向量能够生成相应大小的整个向量空间</p><p>因此，如果需要确定一个向量空间，那么只需要把向量空间对应的基找出来即可，向量空间对应的基包含了这个向量空间的全部有用信息。</p><p>进一步，对于向量空间<spanclass="math inline">\(\mathbb{R}^n\)</span>中的<spanclass="math inline">\(n\)</span>个向量，如果想要构成基，那么以这<spanclass="math inline">\(n\)</span>个向量为列向量的矩阵<spanclass="math inline">\(A\)</span>必然是可逆的。</p><p>显然向量空间<spanclass="math inline">\(\mathbb{R}^n\)</span>的基有无穷多个，而我们平常在选取的时候，则一般会选择标准基，所谓的<strong>标准基</strong>，就是向量空间中最明显的基，把每个基向量以一定顺序作为列向量，可以组成一个单位矩阵。另一方面，这无穷多个基有着一个共同点：基所包含的向量（基向量）的个数是一定的。而这个确定的基向量的个数实际上就表示了向量空间的大小，我们一般称其为向量空间的“<strong>维数</strong>”。</p><h2 id="示例">示例</h2>$ A=<span class="math display">\[\begin{bmatrix}1 &amp; 2 &amp; 3 &amp; 1\\ 1 &amp; 1 &amp; 2 &amp; 1\\ 1 &amp; 2 &amp; 3 &amp; 1\end{bmatrix}\]</span><p>$</p><p>A的列向量线性相关，其零空间中有非零向量，所以<spanclass="math inline">\(rank(A)=2\)</span>，即主元存在的列数，亦是列空间的维数。</p>可以很容易的求得<span class="math inline">\(Ax=0\)</span>的两个解，如$x_1=<span class="math display">\[\begin{bmatrix}-1\\ -1\\ 1\\ 0\end{bmatrix}\]</span>, x_2=<span class="math display">\[\begin{bmatrix}-1\\ 0\\ 0\\ 1\end{bmatrix}\]</span><p><spanclass="math inline">\(，而特解的个数就是自由变量的个数，所以\)</span>n-rank(A)=2$，即自由变量存在的列数，亦是零空间的维数。</p><p>由此观之： - 列空间维数<span class="math inline">\(dim C(A)=rank(A),C(A)\in \mathbb{R}^m\)</span> - 零空间维数<spanclass="math inline">\(dim N(A)=n-rank(A), N(A)\in\mathbb{R}^n\)</span></p>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(八)——求解Ax=b：可解性和解的结构</title>
    <link href="/2022/05/04/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%85%AB)%E2%80%94%E2%80%94%E6%B1%82%E8%A7%A3Ax-b%EF%BC%9A%E5%8F%AF%E8%A7%A3%E6%80%A7%E5%92%8C%E8%A7%A3%E7%9A%84%E7%BB%93%E6%9E%84/"/>
    <url>/2022/05/04/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%85%AB)%E2%80%94%E2%80%94%E6%B1%82%E8%A7%A3Ax-b%EF%BC%9A%E5%8F%AF%E8%A7%A3%E6%80%A7%E5%92%8C%E8%A7%A3%E7%9A%84%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>这一讲系统的讲解了线性方程组<spanclass="math inline">\(Ax=b\)</span>的求解，对可解性和解的结构进行了展开说明，得到了具体的通用解法：<spanclass="math inline">\(X_p+X_n\)</span>，并按照秩与<spanclass="math inline">\(m,n\)</span>的关系对解做了归类。</p><h1 id="求解axb可解性和解的结构">求解<spanclass="math inline">\(Ax=b\)</span>：可解性和解的结构</h1><p>我们知道<span class="math inline">\(Ax=b\)</span>未必有解，当<spanclass="math inline">\(A\)</span>的列空间无法线性组合出<spanclass="math inline">\(b\)</span>时，方程组是无解的。而在有解时可能存在唯一解，也可能存在无穷多个解，那么这其中又有什么规律呢？我们尝试按照上一讲对<spanclass="math inline">\(Ax=0\)</span>的研究方法来进行消元操作。</p><h2 id="可解性">可解性</h2>依然采用上一讲的矩阵：$A=<span class="math display">\[\begin{bmatrix}1 &amp; 2 &amp; 2 &amp; 2\\ 2 &amp; 4 &amp; 6 &amp; 8\\ 3 &amp; 6 &amp; 8 &amp; 10\end{bmatrix}\]</span><p><span class="math inline">\(，求\)</span>Ax=b$的特解。</p><p>这一次<span class="math inline">\(b\)</span>不再是<spanclass="math inline">\(0\)</span>向量，我们消元时写出增广矩阵： <spanclass="math display">\[\left[\begin{array}{c c c c|c}1 &amp; 2 &amp; 2 &amp; 2 &amp; b_1\\ 2 &amp; 4 &amp; 6 &amp; 8 &amp; b_2\\ 3 &amp; 6 &amp; 8 &amp; 10 &amp; b_3\end{array}\right]\underrightarrow{消元}\left[\begin{array}{c c c c|c}1 &amp; 2 &amp; 2 &amp; 2 &amp; b_1\\ 0 &amp; 0 &amp; 2 &amp; 4 &amp; b_2-2b_1\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; b_3-b_2-b_1\end{array}\right]\]</span></p><p>从最后一行可见，要使<spanclass="math inline">\(Ax=b\)</span>有解，则必须满足<spanclass="math inline">\(b_3-b_2-b_1=0\)</span>，而这就是可解性。</p><blockquote><p>我们此前按照列空间视角：<spanclass="math inline">\(b\)</span>必须要属于<spanclass="math inline">\(A\)</span>的列空间才有解，也就是<spanclass="math inline">\(A\)</span>中各列的线性组合。而这里我们换个角度来理解可解性。</p></blockquote><p>我们尝试归纳一下可解性：如果<spanclass="math inline">\(A\)</span>中各行线性组合产生了零行，那么向量<spanclass="math inline">\(b\)</span>的分量在同样的线性组合后也必须为零。</p><h2 id="解的结构">解的结构</h2><p>我们假设<span class="math inline">\(b=\begin{bmatrix} 1\\ 5\\ 6\end{bmatrix}\)</span>满足可解性，那么<spanclass="math inline">\(Ax=b\)</span>的解是什么呢？直观上来看，消元以后我们得到了两个方程，但是未知数有4个，因此，理论上我们可以找到无穷多个解（因为存在自由变量）。<span class="math display">\[\begin{cases}x_1+2x_2+2x_3+2x_4 = 1\\ 2x_3+4x_4 = 3\end{cases}\]</span></p><p>首先我们找出一个特解：先让所有的自由变量取<spanclass="math inline">\(0\)</span>，以解出此时主变量的值。这里自由变量是<spanclass="math inline">\(x_2\)</span>和<spanclass="math inline">\(x_4\)</span>，带入其中求得<spanclass="math inline">\(x_1=-2,x_3=\frac{3}{2}\)</span>，故特解<spanclass="math inline">\(x_p=\begin{bmatrix} -2\\ 0\\ \frac{3}{2}\\ 0\end{bmatrix}\)</span>。</p><p>显然，将特解<spanclass="math inline">\(x_p\)</span>加上上一讲所学的零空间中的任意向量(写为<spanclass="math inline">\(x_n\)</span>)即可得到通解：<spanclass="math inline">\(x=x_p+x_n\)</span>。</p><blockquote><p>显然A(x_p+x_n)=<spanclass="math inline">\(Ax_p+Ax_n=b+0=b\)</span></p></blockquote><p>而上一讲中我们得到了<spanclass="math inline">\(x_n=x_4\begin{bmatrix} 2\\ 0\\ -2\\ 1\end{bmatrix}+x_2\begin{bmatrix} -2\\ 1\\ 0\\ 0\end{bmatrix}\)</span></p><blockquote><p>自由变量取<spanclass="math inline">\(0\)</span>只是为了方便计算，实际上你想取啥都行，因为它们就是从自由变量那里“借”来的。</p></blockquote><h2 id="解与秩的关系">解与秩的关系</h2><p>考虑秩为<span class="math inline">\(r\)</span>的<spanclass="math inline">\(m\times n\)</span>的矩阵<spanclass="math inline">\(A\)</span>，显然<span class="math inline">\(r\leqm, r\leq n\)</span>。 当列满秩时(<spanclass="math inline">\(r=n\)</span>)，意味着每一列都有主元，那么也就没有自由变量，此时零空间只有零向量，因此若<spanclass="math inline">\(b\)</span>满足可解性，则解唯一。</p><p>而当行满秩时(<spanclass="math inline">\(r=m\)</span>)，意味着每一行都有主元，即没有零行，此时对<spanclass="math inline">\(b\)</span>就没有任何约束，那么<spanclass="math inline">\(Ax=b\)</span>是必然有解的。进一步，当<spanclass="math inline">\(m&lt;n\)</span>时，此时意味着存在自由列（自由变量），此时零空间还有特解的线性组合，因此<spanclass="math inline">\(Ax=b\)</span>有无穷解；而当<spanclass="math inline">\(m=n\)</span>时，则不存在自由列，因此仅有唯一解。</p><p>总结如下： <span class="math display">\[\begin{array}{c|c|c|c}r=m=n&amp;r=n\lt m&amp;r=m\lt n&amp;r\lt m,r\lt n\\ R=I&amp;R=\begin{bmatrix}I\\0\end{bmatrix}&amp;R=\begin{bmatrix}I&amp;F\end{bmatrix}&amp;R=\begin{bmatrix}I&amp;F\\0&amp;0\end{bmatrix}\\1\ solution&amp;0\ or\ 1\ solution&amp;\infty\ solution&amp;0\ or\\infty\ solution\end{array}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(七)——求解Ax=0：主变量，特解</title>
    <link href="/2022/05/04/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%B8%83)%E2%80%94%E2%80%94%E6%B1%82%E8%A7%A3Ax-0%EF%BC%9A%E4%B8%BB%E5%8F%98%E9%87%8F%EF%BC%8C%E7%89%B9%E8%A7%A3/"/>
    <url>/2022/05/04/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%B8%83)%E2%80%94%E2%80%94%E6%B1%82%E8%A7%A3Ax-0%EF%BC%9A%E4%B8%BB%E5%8F%98%E9%87%8F%EF%BC%8C%E7%89%B9%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>这一讲深入探讨了求解<spanclass="math inline">\(Ax=0\)</span>过程中，消元法所得到的主列、自由列、自由变量与特解以及它们与矩阵的秩的关系。</p><span id="more"></span><h1 id="求解ax0-主变量特解">求解<spanclass="math inline">\(Ax=0\)</span>: 主变量，特解</h1><p>给定一个<span class="math inline">\(3\times 4\)</span>的矩阵： <spanclass="math inline">\(A=\begin{bmatrix}  1&amp;2&amp;2&amp;2  \\2&amp;4&amp;6&amp;8  \\ 3&amp;6&amp;8&amp;10 \end{bmatrix}\)</span></p><p>欲求<spanclass="math inline">\(Ax=0\)</span>的特解，首先通过高斯消元法找到主变量：<span class="math display">\[A=\begin{bmatrix}1 &amp; 2 &amp; 2 &amp; 2\\ 2 &amp; 4 &amp; 6 &amp; 8\\ 3 &amp; 6 &amp; 8 &amp; 10\end{bmatrix}\underrightarrow{eliminate}\begin{bmatrix}\underline{1} &amp; 2 &amp; 2 &amp; 2\\ 0 &amp; 0 &amp; \underline{2} &amp; 4\\ 0 &amp; 0 &amp; 0 &amp; 0\end{bmatrix}=U\]</span></p><p>可以看出经过消元后，主变量还剩2个（下划线元素），因此矩阵<spanclass="math inline">\(A\)</span>的秩就是2，即<spanclass="math inline">\(r=2\)</span>。主变量所在的列我们称为主列，其余列则称为自由列。自由列中的变量我们称为自由变量，那么自由变量的个数就是：<spanclass="math inline">\(n-r=4-2=2\)</span>。</p><p>高斯消元处理后，线性相关的行就会被暴露出来，比如<spanclass="math inline">\(A\)</span>矩阵的行三实际上就是行一和行二的加和，所以在消元后整行都变成了<spanclass="math inline">\(0\)</span>(<spanclass="math inline">\(0\)</span>行，即没有主元)。另一方面，线性相关的列也会被暴露，我们在消元过程中发现第二列原本要做主元的元素变成了0，这恰恰是因为第二列和前面的列（这里只有第一列）线性相关（刚好是2倍列1），因此第二列没有主元，是自由列。而同样的，第四列也没有主元，这就说明第四列实际上是前三列的线性组合（二倍第三列减去第二列）。</p><p>消元的本质是行变换，行变换改变的是列向量（从而可能改变列空间），但是无法改变列向量之间的线性相关性。另一方面，消元不会改变零空间，因为<spanclass="math inline">\(b\)</span>为<spanclass="math inline">\(0\)</span>时，随你怎么折腾，他都是<spanclass="math inline">\(0\)</span>，解不会改变。</p><p>因此，<span class="math inline">\(Ax=0\)</span>求解问题变成了对<spanclass="math inline">\(Ux=0\)</span>的求解，首先我们找出主变量和自由变量，<spanclass="math inline">\(x_1\)</span>和<spanclass="math inline">\(x_3\)</span>是主变量，<spanclass="math inline">\(x_2\)</span>和<spanclass="math inline">\(x_4\)</span>是自由变量。自由变量可以对其分配任意的值（不关你赋什么值，都会被其他线性相关的列的某个值里抵消掉）。</p><p><strong>我们对自由变量随意赋值，一般采用的一种简单策略是：对其中一个自由变量赋值为<spanclass="math inline">\(1\)</span>，其余赋值为<spanclass="math inline">\(0\)</span>，循环往复。</strong></p><blockquote><p>这种策略非常优雅且直观，类似控制变量法的思想，我们每次只关注其中一个自由变量，其他都砍成<spanclass="math inline">\(0\)</span>，这样就可以避免自由变量的相互影响，从而得到所有的线性无关的特解。</p></blockquote><p>通过这样的策略，我们对自由变量进行赋值，并回代求出主变量： - 令<spanclass="math inline">\(x_2=1, x_4=0\)</span>求得特解<spanclass="math inline">\(x=c_1\begin{bmatrix}-2\\ 1\\ 0\\0\end{bmatrix}\)</span> - 令<span class="math inline">\(x_2=0,x_4=1\)</span>求得特解<spanclass="math inline">\(x=c_2\begin{bmatrix}2\\ 0\\ -2\\1\end{bmatrix}\)</span></p><p>到这里，结果就很显而易见了：<strong>零空间所包含的就是特解的线性组合，每个自由变量对应着一个特解，特解之间线性无关。</strong></p><h2 id="rrefreduced-row-echelon-form">RREF(Reduced row echelonform)</h2><p>上例中消元得到的<spanclass="math inline">\(U\)</span>矩阵是个上三角阵，实际上还可以进一步简化成<spanclass="math inline">\(R\)</span>矩阵，即RREF(Reduced row echelonform)——简化行阶梯形式。</p><p><span class="math inline">\(R\)</span>矩阵中主元上下的元素都是0：<span class="math display">\[U=\begin{bmatrix}\underline{1} &amp; 2 &amp; 2 &amp; 2\\ 0 &amp; 0 &amp; \underline{2} &amp; 4\\ 0 &amp; 0 &amp; 0 &amp; 0\end{bmatrix}\underrightarrow{自底向上}\begin{bmatrix}\underline{1} &amp; 2 &amp; 0 &amp; -2\\ 0 &amp; 0 &amp; \underline{1} &amp; 2\\ 0 &amp; 0 &amp; 0 &amp; 0\end{bmatrix}=R\]</span></p><p>将<spanclass="math inline">\(R\)</span>矩阵中的主变量放在一起，自由变量放在一起（列交换），得到：<span class="math display">\[R=\begin{bmatrix}\underline{1} &amp; 2 &amp; 0 &amp; -2\\ 0 &amp; 0 &amp; \underline{1} &amp; 2\\ 0 &amp; 0 &amp; 0 &amp; 0\end{bmatrix}\underrightarrow{列交换}\left[\begin{array}{c c | c c}1&amp;0&amp;2&amp;-2\\0&amp;1&amp;0&amp;2\\ \hline 0&amp;0&amp;0&amp;0\end{array}\right]=\begin{bmatrix}I &amp; F\\ 0 &amp; 0\end{bmatrix}\textrm{，其中}I\textrm{为单位矩阵，}F\textrm{为自由变量组成的矩阵}\]</span></p><p>计算零空间矩阵<span class="math inline">\(N\)</span>（nullspacematrix），其列为特解，有<span class="math inline">\(RN=0\)</span>。<span class="math display">\[x_{pivot}=-Fx_{free}\\ \begin{bmatrix}I&amp;F\end{bmatrix}\begin{bmatrix}x_{pivot}\\ x_{free}\end{bmatrix}=0\\ N=\begin{bmatrix}-F\\ I\end{bmatrix}\]</span></p>在本例中$N=<span class="math display">\[\begin{bmatrix}-2&amp;2\\ 0&amp;-2\\ 1&amp;0\\ 0&amp;1\end{bmatrix}\]</span><p><spanclass="math inline">\(，与上面求得的两个\)</span>x$特解一致。</p><p>主元的概念是消元带来的，而消元过程中挖掘的实际上就是行、列的线性相关性。<strong>总结：<span class="math inline">\(A\)</span> 的主元个数 = <spanclass="math inline">\(A\)</span> 矩阵线性无关的列的个数 = <spanclass="math inline">\(A^T\)</span> 矩阵线性无关的行的个数 = <spanclass="math inline">\(A^T\)</span> 的主元个数。</strong></p>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(六)——列空间和零空间</title>
    <link href="/2022/05/03/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%85%AD)%E2%80%94%E2%80%94%E5%88%97%E7%A9%BA%E9%97%B4%E5%92%8C%E9%9B%B6%E7%A9%BA%E9%97%B4/"/>
    <url>/2022/05/03/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%85%AD)%E2%80%94%E2%80%94%E5%88%97%E7%A9%BA%E9%97%B4%E5%92%8C%E9%9B%B6%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p>这一讲主要介绍了<strong>列空间</strong>和<strong>零空间</strong>。二者都是四个基本子空间的重要成员。</p><span id="more"></span><h1 id="列空间和零空间">列空间和零空间</h1><h2 id="子空间的并和交">子空间的并和交</h2><p>某向量空间的两个子空间<span class="math inline">\(P\)</span>和<spanclass="math inline">\(L\)</span>，它们的并（<spanclass="math inline">\(P\cup L\)</span>）不一定是子空间，但它们的交(<spanclass="math inline">\(P\capL\)</span>)一定是子空间，这一点是显而易见的。</p><h2 id="列空间大小">列空间大小</h2><p><span class="math display">\[\begin{bmatrix}a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1(n-1)} &amp; a_{1n}\\ a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2(n-1)} &amp; a_{2n}\\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots\\ a_{m1} &amp; a_{m2} &amp; \cdots &amp; a_{m(n-1)} &amp; a_{mn}\end{bmatrix}\cdot\begin{bmatrix}x_{1}\\ x_{2}\\ \vdots\\ x_{n-1}\\ x_{n}\end{bmatrix}=\begin{bmatrix}b_{1}\\ b_{2}\\ \vdots\\ b_{m}\end{bmatrix}\]</span></p><p>矩阵<spanclass="math inline">\(A\)</span>的列空间是由它的各列线性组合构成。在探究列空间的大小时，又将回到这个问题：<spanclass="math inline">\(Ax=b\)</span>是否对任意的<spanclass="math inline">\(b\)</span>都有解？或者说，什么样的<spanclass="math inline">\(b\)</span>方程组才有解？</p><p>从列空间的视角出发，这一问题有更加具象的回答方式：<strong><spanclass="math inline">\(Ax=b\)</span>有解，当且仅当<spanclass="math inline">\(b\)</span>属于<spanclass="math inline">\(A\)</span>的列空间。只有当<spanclass="math inline">\(b\)</span>是<spanclass="math inline">\(A\)</span>各列的线性组合时，<spanclass="math inline">\(Ax=b\)</span>才有解。</strong></p><p>因此，矩阵列空间的大小实际上与各列的线性无关性有关系，越多的列线性无关，那么它们能构成的列空间就越大，越多的列线性相关，那么其中相关的那一部分对列空间的构建就毫无贡献。</p><h2 id="零空间">零空间</h2><p>零空间由让<span class="math inline">\(Ax=0\)</span>成立的所有<spanclass="math inline">\(x\)</span>组成。显然，零空间包含零向量，而零空间本身也是向量空间（满足矩阵加法与数乘的封闭性）。</p><blockquote><p>特别注意：零空间不是零向量空间，零向量空间只包含一个零向量，本质上是<spanclass="math inline">\(R^0\)</span>，零空间是一种子空间，可以包含无数个向量。</p></blockquote><p>如果<span class="math inline">\(b\not=0\)</span>，那么对于<spanclass="math inline">\(x\)</span>的求解是否能够找到一种向量空间呢？显然答案是不能，因为若 <spanclass="math inline">\(b\not=0\)</span>，那么<spanclass="math inline">\(x\)</span>就不可能等于<spanclass="math inline">\(0\)</span>，这就意味着如果要形成向量空间，那么是不包含零向量的，显然这违背了我们此前的推论：向量空间必然包含零向量。因此，解集并不能构成一个向量空间。</p>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(五)——转置、置换和向量空间R</title>
    <link href="/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%94)%E2%80%94%E2%80%94%E8%BD%AC%E7%BD%AE%E3%80%81%E7%BD%AE%E6%8D%A2%E5%92%8C%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4R/"/>
    <url>/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%94)%E2%80%94%E2%80%94%E8%BD%AC%E7%BD%AE%E3%80%81%E7%BD%AE%E6%8D%A2%E5%92%8C%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4R/</url>
    
    <content type="html"><![CDATA[<p>这一讲内容包括转置、置换和向量空间<spanclass="math inline">\(R\)</span>，实际上是基于<spanclass="math inline">\(A=LU\)</span>的剖解提纲挈领，形而上学，引出线性代数的核心内容——向量空间。</p><span id="more"></span><h1 id="转置置换和向量空间r">转置、置换和向量空间R</h1><p>对于可逆矩阵<spanclass="math inline">\(A\)</span>，在消元过程中可能会遇到主元为0的情况，此时就需要进行行变换，而行变换的本质实际上就是左乘一个置换矩阵<spanclass="math inline">\(P\)</span>而已。上一讲中已经讲过了置换矩阵<spanclass="math inline">\(P\)</span>，当它左乘矩阵<spanclass="math inline">\(A\)</span>时，从行视角来看实际上就是对<spanclass="math inline">\(A\)</span>的行进行交换。当行变换找到新的不为0的主元时，消元得以继续进行。</p><h2 id="对称矩阵">对称矩阵</h2><p>转置以后矩阵没有发生变化的矩阵，称为对称矩阵，即<spanclass="math inline">\(A^T=A\)</span>，置换矩阵群中有4个就是对称矩阵。一种简单的生成对称矩阵的方法是：矩阵的转置和矩阵自身相乘<spanclass="math inline">\((R^TR)\)</span>。</p><p>证明如下： <span class="math display">\[(R^TR)^T = R^T(R^T)^T = R^TR\]</span></p><p>显然，矩阵<spanclass="math inline">\(R\)</span>转置后再转置就是本体，因此上式成立。</p><h2 id="向量空间">向量空间</h2><p>何为向量空间： 1. 必须通过原点。 2.向量空间必须对数乘和加法两种运算是封闭的，亦即对线性组合封闭。</p><blockquote><p>所谓封闭，就是说任意向量的数乘、求和运算得到的向量也在该空间中。至于必须通过原点，这是显然的，如果不通过原点，那么空间不可能封闭。</p></blockquote><p>高维向量空间又包含各种低维的向量子空间。</p><h3 id="二维向量空间">二维向量空间</h3><p>对于<spanclass="math inline">\(R^2\)</span>来说，向量空间内的子空间可以轻易的枚举：- <span class="math inline">\(R^2\)</span>本身 - 任何过原点的直线 -零向量空间(只包含零向量)</p><h3 id="三维向量空间">三维向量空间</h3><p>进一步，对于<spanclass="math inline">\(R^3\)</span>来说，子空间就多了一个维度： - <spanclass="math inline">\(R^3\)</span>本身 - 任何过原点的直线 -任何过原点的平面 - 零向量空间(只包含零向量)</p><p>显然，<spanclass="math inline">\(R^2\)</span>的向量子空间是更高维度<spanclass="math inline">\(R^3\)</span>子空间的子集，以此类推。</p><p>那么矩阵是如何构建向量子空间的呢？显而易见的方法是通过枚举列向量来构造：即选取各列进行线性组合，所有线性组合的结果构成的就是一个特定的子空间，这个子空间一般称作矩阵的列空间，记为<spanclass="math inline">\(C(A)\)</span>，它也是矩阵4大重要子空间中的一个。</p><blockquote><p>这一讲主要是为了让大家先接受向量空间这一概念，因为线性代数的核心都是围绕着向量空间来描摹，如果不能在脑海中将矩阵投射成向量空间来理解，那么后续的课程也都无法真正掌握。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(四)——A的LU分解</title>
    <link href="/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%9B%9B)%E2%80%94%E2%80%94A%E7%9A%84LU%E5%88%86%E8%A7%A3/"/>
    <url>/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E5%9B%9B)%E2%80%94%E2%80%94A%E7%9A%84LU%E5%88%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>本讲主要是围绕<span class="math inline">\(A\)</span>的<spanclass="math inline">\(LU\)</span>分解，深入展开矩阵乘法、逆与转置的关系。最后自然而然的引出了置换矩阵。</p><span id="more"></span><h1 id="a的lu分解"><span class="math inline">\(A\)</span>的<spanclass="math inline">\(LU\)</span>分解</h1><h2 id="ab的逆"><span class="math inline">\(AB\)</span>的逆</h2><p><span class="math inline">\(AB\)</span>如果有逆，那么其逆显然是<spanclass="math inline">\(B^{-1}A^{-1}\)</span>，因为有： <spanclass="math display">\[(AB)(B^{-1} A^{-1})=I\\ (B^{-1} A^{-1})(AB)=I\]</span></p><p>根据结合律法则，我们把括号挪一下，俩俩结合成<spanclass="math inline">\(I\)</span>，上式一目了然。</p><h2 id="ab的转置"><span class="math inline">\(AB\)</span>的转置</h2><p>显然是<span class="math inline">\(B^TA^T\)</span>（用<spanclass="math inline">\(C\)</span>每个元素的求和分别计算即可证等），由此可见转置如果想要拆除括号，则内层矩阵的转置顺序要倒置。</p><h2 id="at的逆"><span class="math inline">\(A^T\)</span>的逆</h2><p>显然： <span class="math display">\[(AA^{-1})^T = I^T = I\\ (A^{-1})^TA^T = I\]</span></p><p>因此<span class="math inline">\(A^T\)</span>的逆矩阵就是<spanclass="math inline">\((A^{-1})^T\)</span>，即<spanclass="math inline">\((A^T)^{-1}=(A^{-1})^T\)</span>。</p><h2 id="alu和eau的关系"><span class="math inline">\(A=LU\)</span>和<spanclass="math inline">\(EA=U\)</span>的关系</h2><p>通过不断的左乘，可以让矩阵<spanclass="math inline">\(A\)</span>变换为<spanclass="math inline">\(U\)</span>，而只需要在乘法两边同时做乘<spanclass="math inline">\(E^{-1}\)</span>，就会得到<spanclass="math inline">\(A=E^{-1}U\)</span>，显然，<spanclass="math inline">\(L\)</span>和<spanclass="math inline">\(U\)</span>互为逆矩阵，<spanclass="math inline">\(U\)</span>是一个上三角，而<spanclass="math inline">\(L\)</span>则是一个下三角。</p><p>将<span class="math inline">\(n\)</span>阶方阵<spanclass="math inline">\(A\)</span>变换为<spanclass="math inline">\(LU\)</span>需要的计算量也很好估计，时间复杂度为<spanclass="math inline">\(O(n^2+(n-1)^2+\dots+2^2+1^2)\)</span>，平方和相加我们初中就知道它等于<spanclass="math inline">\(O(\frac{n^3}{3})\)</span>。</p><h2 id="置换矩阵">置换矩阵</h2><p>3阶置换矩阵有6个： <span class="math display">\[\begin{bmatrix}1 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 1\end{bmatrix}\begin{bmatrix}0 &amp; 1 &amp; 0\\ 1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 1\\ 0 &amp; 1 &amp; 0\\ 1 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1\\ 0 &amp; 1 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 1\\ 1 &amp; 0 &amp; 0\end{bmatrix}\begin{bmatrix}0 &amp; 0 &amp; 1\\ 1 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0\end{bmatrix}\]</span></p><p>这6个置换矩阵组成了一个很有意思的矩阵群，它们有非常有意思的性质：置换矩阵的逆等于其转置，这一点非常好理解，相当于被交换的列又再次被交换回来。</p><p><span class="math inline">\(n\)</span>阶方阵的置换矩阵有<spanclass="math inline">\(\binom{n}{1}=n!\)</span>个。</p>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(三)——乘法和逆矩阵</title>
    <link href="/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%B8%89)%E2%80%94%E2%80%94%E4%B9%98%E6%B3%95%E5%92%8C%E9%80%86%E7%9F%A9%E9%98%B5/"/>
    <url>/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%B8%89)%E2%80%94%E2%80%94%E4%B9%98%E6%B3%95%E5%92%8C%E9%80%86%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<p>这一讲是对矩阵乘法和逆矩阵的深入说明。矩阵乘法主要介绍了按不同视角来理解的多种计算方式。逆矩阵则给出了求解非奇异矩阵的逆矩阵的方法。</p><span id="more"></span><h1 id="乘法和逆矩阵">乘法和逆矩阵</h1><h2 id="矩阵乘法的视觉意义">矩阵乘法的视觉意义</h2><p>矩阵乘法<span class="math inline">\(AB=C\)</span>，其中<spanclass="math inline">\(A\)</span>是<span class="math inline">\(m\timesn\)</span>阵，<span class="math inline">\(B\)</span>是<spanclass="math inline">\(n\times p\)</span>阵，我们知道得到的<spanclass="math inline">\(C\)</span>是一个<spanclass="math inline">\(m\times p\)</span>阵。对于<spanclass="math inline">\(C\)</span>中第<spanclass="math inline">\(i\)</span>行第<spanclass="math inline">\(j\)</span>列元素<spanclass="math inline">\(C_{ij}\)</span>。</p><p>从不同视角看矩阵乘法，我们可以给出不同的计算式：</p><h3 id="从每个元素的角度">从每个元素的角度</h3><p>有： <span class="math display">\[c_{ij}=row_i\cdot column_j = \sum_{k=i}^na_{ik}b_{kj}\]</span></p><p>其中<span class="math inline">\(a_{ik}\)</span>是矩阵<spanclass="math inline">\(A\)</span>的第<spanclass="math inline">\(i\)</span>行第<spanclass="math inline">\(k\)</span>列元素，<spanclass="math inline">\(b_{kj}\)</span>是<spanclass="math inline">\(B\)</span>矩阵第<spanclass="math inline">\(k\)</span>行第<spanclass="math inline">\(j\)</span>列元素。 <spanclass="math inline">\(c_{ij}\)</span>可以看成是<spanclass="math inline">\(A\)</span>的第<spanclass="math inline">\(i\)</span>行乘以<spanclass="math inline">\(B\)</span>的第<spanclass="math inline">\(j\)</span>列。</p><h3 id="列的线性组合">列的线性组合</h3><p>从列的角度看，<span class="math inline">\(C\)</span>的各列是<spanclass="math inline">\(A\)</span>中各列的线性组合，组合方式由<spanclass="math inline">\(B\)</span>来确定。比如<spanclass="math inline">\(C\)</span>的第一列是 <spanclass="math inline">\(A\)</span>中各列相对于<spanclass="math inline">\(B\)</span>的第一列的一个线性组合。</p><p><span class="math display">\[\begin{bmatrix}&amp;&amp;\\ A_{col1}&amp;A_{col2}&amp;\cdots&amp;A_{coln}\\ &amp;&amp;\end{bmatrix}\begin{bmatrix}\cdots&amp;b_{1j}&amp;\cdots\\ \cdots&amp;b_{2j}&amp;\cdots\\ \cdots&amp;\vdots&amp;\cdots\\ \cdots&amp;b_{nj}&amp;\cdots\\ \end{bmatrix}=\begin{bmatrix}&amp;&amp;\\\cdots&amp;\left(b_{1j}A_{col1}+b_{2j}A_{col2}+\cdots+b_{nj}A_{coln}\right)&amp;\cdots\\ &amp;&amp;\end{bmatrix}\]</span></p><p>上面的运算为<span class="math inline">\(B\)</span>的第<spanclass="math inline">\(j\)</span>个列向量右乘矩阵<spanclass="math inline">\(A\)</span>，求得的结果就是<spanclass="math inline">\(C\)</span>矩阵的第<spanclass="math inline">\(j\)</span>列，即<spanclass="math inline">\(C\)</span>的第<spanclass="math inline">\(j\)</span>列是<spanclass="math inline">\(A\)</span>的列向量以<spanclass="math inline">\(B\)</span>的第<spanclass="math inline">\(j\)</span>列作为系数所求得的线性组合，<spanclass="math inline">\(C_j=b_{1j}A_{col1}+b_{2j}A_{col2}+\cdots+b_{nj}A_{coln}\)</span>。</p><h3 id="行的线性组合">行的线性组合</h3><p><span class="math inline">\(C\)</span>的各行是<spanclass="math inline">\(B\)</span>中各行的一个线性组合，组合方式由<spanclass="math inline">\(A\)</span>决定。比如<spanclass="math inline">\(C\)</span>的第一行是<spanclass="math inline">\(B\)</span>中各行相对于<spanclass="math inline">\(A\)</span>的第一行的一个线性组合。</p><p><span class="math display">\[\begin{bmatrix}\vdots&amp;\vdots&amp;\vdots&amp;\vdots\\ a_{i1}&amp;a_{i2}&amp;\cdots&amp;a_{in}\\ \vdots&amp;\vdots&amp;\vdots&amp;\vdots\end{bmatrix}\begin{bmatrix}&amp;B_{row1}&amp;\\ &amp;B_{row2}&amp;\\ &amp;\vdots&amp;\\ &amp;B_{rown}&amp;\end{bmatrix}=\begin{bmatrix}\vdots\\ \left(a_{i1}B_{row1}+a_{i2}B_{row2}+\cdots+a_{in}B_{rown}\right)\\ \vdots\end{bmatrix}\]</span></p><p>上面的运算为<span class="math inline">\(A\)</span>的第<spanclass="math inline">\(i\)</span>个行向量左乘矩阵<spanclass="math inline">\(B\)</span>，求得的结果就是<spanclass="math inline">\(C\)</span>矩阵的第<spanclass="math inline">\(i\)</span>行，即<spanclass="math inline">\(C\)</span>的第<spanclass="math inline">\(i\)</span>行是<spanclass="math inline">\(B\)</span>的行向量以<spanclass="math inline">\(A\)</span>的第<spanclass="math inline">\(i\)</span>行作为系数所求的的线性组合，<spanclass="math inline">\(C_i=a_{i1}B_{row1}+a_{i2}B_{row2}+\cdots+a_{in}B_{rown}\)</span>。</p><h3 id="从矩阵的角度看">从矩阵的角度看</h3><p><span class="math inline">\(A\)</span>的列乘以<spanclass="math inline">\(B\)</span>的行： <span class="math display">\[\begin{bmatrix}&amp;&amp;\\ A_{col1}&amp;A_{col2}&amp;\cdots&amp;A_{coln}\\ &amp;&amp;\end{bmatrix}\begin{bmatrix}&amp;B_{row1}&amp;\\ &amp;B_{row2}&amp;\\ &amp;\vdots&amp;\\ &amp;B_{rown}&amp;\end{bmatrix}=A_{col1}B_{row1}+A_{col2}B_{row2}+\cdots+A_{coln}B_{rown}\]</span></p><p><span class="math inline">\(A_{coli}B_{rowi}\)</span>是一个<spanclass="math inline">\(m\times 1\)</span>向量乘以一个<spanclass="math inline">\(1\times p\)</span>向量，其结果是一个<spanclass="math inline">\(m\times p\)</span>矩阵，而所有的<spanclass="math inline">\(m\times p\)</span>矩阵之和就是计算结果。</p><h3 id="分块来看">分块来看</h3><p><span class="math display">\[\left[\begin{array}{c|c}A_1&amp;A_2\\ \hlineA_3&amp;A_4\end{array}\right]\left[\begin{array}{c|c}B_1&amp;B_2\\\hlineB_3&amp;B_4\end{array}\right]=\left[\begin{array}{c|c}A_1B_1+A_2B_3&amp;A_1B_2+A_2B_4\\\hline A_3B_1+A_4B_3&amp;A_3B_2+A_4B_4\end{array}\right]\]</span></p><p>简写成： <span class="math display">\[\left[\begin{array}{c|c}A_1&amp;A_2\\ \hlineA_3&amp;A_4\end{array}\right]\left[\begin{array}{c|c}B_1&amp;B_2\\\hlineB_3&amp;B_4\end{array}\right]=\left[\begin{array}{c|c}C_1&amp;C_2\\\hline C_3&amp;C_4\end{array}\right]\]</span></p><p>可以看到 矩阵完全可以拆成多个块，各块的关联关系也一目了然。</p><h2 id="逆矩阵">逆矩阵</h2><p>逆矩阵分为左逆和右逆，不是所有方阵都可逆，对于方阵来说，左逆和右逆是相等的。</p><p>对这些有逆的矩阵，我们称其为可逆的或非奇异的。</p><p>如何判断一个矩阵是可逆的？从列图像来看，如果<spanclass="math inline">\(A^{-1}\)</span>存在，那么有<spanclass="math inline">\(AA^{-1}=I\)</span>，如果<spanclass="math inline">\(A\)</span>中各列无法线性组合成单位阵，则矩阵不可逆。相反，如果可以找到非零向量<spanclass="math inline">\(x\)</span>使得<spanclass="math inline">\(Ax=0\)</span>有解，那么<spanclass="math inline">\(A\)</span>也是不可逆的（某些列是相关的，反证法非常容易求证）。</p><p>那么如何求解一个逆矩阵呢？可以采用高斯-若尔当思想：构造这样一个增广矩阵： <spanclass="math inline">\(\left[\begin{array}{cc|cc}1&amp;3&amp;1&amp;0\\2&amp;7&amp;0&amp;1\end{array}\right]\)</span>，</p><p>右侧补充一个单位阵<spanclass="math inline">\(I\)</span>，接下来用消元法将左侧变为单位矩阵：</p><p><span class="math display">\[\left[\begin{array}{cc|cc}1&amp;3&amp;1&amp;0\\2&amp;7&amp;0&amp;1\end{array}\right]\xrightarrow{row_2-2row_1}\left[\begin{array}{cc|cc}1&amp;3&amp;1&amp;0\\0&amp;1&amp;-2&amp;1\end{array}\right]\xrightarrow{row_1-3row_2}\left[\begin{array}{cc|cc}1&amp;0&amp;7&amp;-3\\0&amp;1&amp;-2&amp;1\end{array}\right]\]</span></p><p>于是，我们就将矩阵从<spanclass="math inline">\(\left[\begin{array}{c|c}A&amp;I\end{array}\right]\)</span>变为<spanclass="math inline">\(\left[\begin{array}{c|c}I&amp;A^{-1}\end{array}\right]\)</span></p><p>而高斯-若尔当思想的本质是使用消元矩阵<spanclass="math inline">\(E\)</span>，对<spanclass="math inline">\(A\)</span>进行操作，<spanclass="math inline">\(E\left[\begin{array}{c|c}A&amp;I\end{array}\right]\)</span>，利用一步步消元有<spanclass="math inline">\(EA=I\)</span>，进而得到<spanclass="math inline">\(\left[\begin{array}{c|c}I&amp;E\end{array}\right]\)</span>，其实这个消元矩阵<spanclass="math inline">\(E\)</span>就是<spanclass="math inline">\(A^{-1}\)</span>，而高斯-若尔当法中的<spanclass="math inline">\(I\)</span>只是负责记录消元的每一步操作，待消元完成，逆矩阵就自然出现了。</p><p><strong>结论：如果矩阵可以通过行变换变成<spanclass="math inline">\(I\)</span>，那么矩阵就是可逆的。</strong></p>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(二)——矩阵消元</title>
    <link href="/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%8C)%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E6%B6%88%E5%85%83/"/>
    <url>/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%BA%8C)%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E6%B6%88%E5%85%83/</url>
    
    <content type="html"><![CDATA[<p>高斯消元法是如今小学生都耳熟能详的解决齐次线性方程组的方法，课程第二讲主要讲授了高斯消元法应用在矩阵上的视觉效果与解读。</p><span id="more"></span><h1 id="矩阵消元">矩阵消元</h1><h2 id="非矩阵视角的消元">非矩阵视角的消元</h2><p>有三元方程组： <spanclass="math inline">\(\begin{cases}  x&amp;+2y&amp;+z&amp;=2  \\3x&amp;+8y&amp;+z&amp;=12  \\&amp;4y&amp;+z&amp;=2  \end{cases}\)</span></p><p>如果我们想通过消元法来解决，那么一般是考虑选中其中的一行，乘以某个系数对另外两行进行加法（系数为负就是减法）操作，以消除掉<spanclass="math inline">\(x\)</span>未知数，如此，后两个方程组就变成了二元一次方程组求解问题，而方法也是以此类推，用其中的一个消掉另一个的<spanclass="math inline">\(y\)</span>，最终剩下的那一行就只有<spanclass="math inline">\(z\)</span>了。在解出<spanclass="math inline">\(z\)</span>以后，再将<spanclass="math inline">\(z\)</span>回代到方程组，进而再解另外两个未知数<spanclass="math inline">\(x,y\)</span>。这种方法我们在小学的时候就已经掌握了。</p><h2 id="矩阵视角的消元">矩阵视角的消元</h2><p>方程组对应的矩阵形式<span class="math inline">\(Ax=b\)</span>为：<span class="math inline">\(\begin{bmatrix}  1&amp;2&amp;1  \\3&amp;8&amp;1  \\ 0&amp;4&amp;1  \end{bmatrix}\begin{bmatrix}  x  \\y  \\ z  \end{bmatrix}=\begin{bmatrix}  2  \\ 12  \\2\end{bmatrix}\)</span>。</p><p>实际上如果将消元的手法应用到矩阵上，本质上也并没有什么不同，从矩阵的视角来看，消元的第一步是选定第一行的第一个元素作为主元（对应<spanclass="math inline">\(x\)</span>系数），分别乘以不同的系数对第二、三行进行加法操作，进而消除掉第二、三行的首个元素。由于第三行原本首个元素就是0，故这里只需要对第二行操作：<spanclass="math inline">\(\begin{bmatrix}  \underline{1}&amp;2&amp;1  \\3&amp;8&amp;1  \\0&amp;4&amp;1\end{bmatrix}\xrightarrow{row_2-3row_1}\begin{bmatrix}  \underline{1}&amp;2&amp;1  \\0&amp;2&amp;-2  \\ 0&amp;4&amp;1\end{bmatrix}\)</span></p><p>这里暂时先不管对<spanclass="math inline">\(b\)</span>的影响（实际上也要跟着变化），矩阵<spanclass="math inline">\(A\)</span>经过消元变成了这个样子。</p><p>接下来，我们如法炮制，选择第二行的第二个元素(对应<spanclass="math inline">\(y\)</span>系数)作为主元，对第三行进行消元动作：<spanclass="math inline">\(\begin{bmatrix}  \underline{1}&amp;2&amp;1  \\0&amp;\underline{2}&amp;-2  \\0&amp;4&amp;1\end{bmatrix}\xrightarrow{row_3-2row_2}\begin{bmatrix}\underline{1}&amp;2&amp;1  \\0&amp;\underline{2}&amp;-2  \\0&amp;0&amp;\underline{5}\end{bmatrix}\)</span></p><p>到此，消元动作结束，最后一行仅剩<spanclass="math inline">\(z\)</span>的系数，即第三个元素5。</p><p>上例的矩阵是精心设计的，实际上消元过程中可能会遇到一些失效的情形：首先主元不能为0，为0的主元无论乘上什么样的系数都无法消除其他行的对应列。其次，如果消元过程中遇到主元位置为0，则需要交换行，使主元不为0。</p><p>消元结束后，我们就可以进行回代，由于方程组在矩阵消元时发生了变化，我们需要对<spanclass="math inline">\(b\)</span>也进行相同的操作以同步这些变化，如此我们写成下面的增广矩阵形式：<span class="math display">\[\left[\begin{array}{c|c}A&amp;b\end{array}\right]=\left[\begin{array}{ccc|c}  1&amp;2&amp;1&amp;2  \\ 3&amp;8&amp;1&amp;12  \\ 0&amp;4&amp;1&amp;2  \end{array}\right]\to\left[\begin{array}{ccc|c}1&amp;2&amp;1&amp;2\\ 0&amp;2&amp;-2&amp;6\\ 0&amp;4&amp;1&amp;2\end{array}\right]\to\left[\begin{array}{ccc|c}1&amp;2&amp;1&amp;2\\ 0&amp;2&amp;-2&amp;6\\ 0&amp;0&amp;5&amp;-10\end{array}\right]\]</span></p><p>此时方程组变为：<spanclass="math inline">\(\begin{cases}x&amp;+2y&amp;+z&amp;=2\\&amp;2y&amp;-2z&amp;=6\\&amp;&amp;5z&amp;=-10\end{cases}\)</span>，最后一行可以得出<spanclass="math inline">\(z=-2\)</span>，回代到<spanclass="math inline">\(2y-2z=6\)</span>得到<spanclass="math inline">\(y=1\)</span>，再进一步得到<spanclass="math inline">\(x=2\)</span>。</p><blockquote><p>可以用这里的方程组和我们小学时学到的消元法得到的方程组作对比，本质上完全一样。</p></blockquote><h2 id="矩阵消元的本质">矩阵消元的本质</h2><p>通过第一节课我们知道，对于矩阵乘法<spanclass="math inline">\(AB\)</span>可以看成是对矩阵<spanclass="math inline">\(B\)</span>中行按<spanclass="math inline">\(A\)</span>中系数的线性组合，如果<spanclass="math inline">\(B\)</span>想要维持不变，那么<spanclass="math inline">\(A\)</span>就得是个单位矩阵<spanclass="math inline">\(I\)</span>: <spanclass="math inline">\(\begin{bmatrix}  1&amp;0&amp;0  \\0&amp;1&amp;0  \\ 0&amp;0&amp;1\end{bmatrix}\)</span>这个单位矩阵就相当于我们实数运算中的1，只不过在矩阵的世界，它长这个样子。</p><blockquote><p>单位阵的三行彼此换一换，就能得到一个置换矩阵群，这个东西很有意思，以后会讲到。</p></blockquote><p>于是我们还原一下消元的第一步操作：<spanclass="math inline">\(row_2-3row_1\)</span> <spanclass="math inline">\(\begin{bmatrix}  1&amp;0&amp;0  \\-3&amp;1&amp;0  \\0&amp;0&amp;1\end{bmatrix}\begin{bmatrix}  1&amp;2&amp;1  \\3&amp;8&amp;1  \\0&amp;4&amp;1\end{bmatrix}=\begin{bmatrix}  1&amp;2&amp;1  \\0&amp;2&amp;-2  \\ 0&amp;4&amp;1\end{bmatrix}\)</span></p><p>这个消元矩阵我们记作<spanclass="math inline">\(E_{21}\)</span>，即将第二行第一个元素变为0。</p><p>同理，我们找到<spanclass="math inline">\(E_{32}\)</span>，将第三行第二个元素变为0： <spanclass="math inline">\(\begin{bmatrix}  1&amp;0&amp;0  \\0&amp;1&amp;0  \\0&amp;-2&amp;1  \end{bmatrix}\begin{bmatrix}  1&amp;2&amp;1  \\0&amp;2&amp;-2  \\0&amp;4&amp;1\end{bmatrix}=\begin{bmatrix}  1&amp;2&amp;1  \\0&amp;2&amp;-2  \\ 0&amp;0&amp;5\end{bmatrix}\)</span></p><p><span class="math inline">\(E_{21}\)</span>和<spanclass="math inline">\(E_{32}\)</span>就是消元过程中用到的两个初等矩阵。</p><p>最后，我们将两步综合起来，即<spanclass="math inline">\(E_{32}(E_{21}A)=U\)</span>。矩阵的乘法是满足结合律的，所以这里的括号可以移动一下，即<spanclass="math inline">\((E_{32}E_{21})A=U\)</span>，这里的<spanclass="math inline">\(U\)</span>表示upper，即上三角矩阵（对角线下面的元素全都是0）。</p><h2 id="逆">逆</h2><p>如此，我们可以通过对<spanclass="math inline">\(A\)</span>做行变换得到<spanclass="math inline">\(U\)</span>，那么显然，如果要从<spanclass="math inline">\(U\)</span>变回<spanclass="math inline">\(A\)</span>我们只需要再反向操作一波即可，比如<spanclass="math inline">\(E_{21}\)</span>是从第二行减去三倍的第一行，那么它的反向操作就应该是第二行加上3倍的第一行，所以其逆矩阵就应该是<spanclass="math inline">\(\begin{bmatrix}1&amp;0&amp;0\\ 3&amp;1&amp;0\\0&amp;0&amp;1\end{bmatrix}\)</span>。</p><p>我们把矩阵<span class="math inline">\(E\)</span>的逆记作<spanclass="math inline">\(E^{-1}\)</span>，显然有<spanclass="math inline">\(E^{-1}E=I\)</span>，从行变换意义上来看，单位阵<spanclass="math inline">\(I\)</span>乘以<spanclass="math inline">\(A\)</span>相当于什么都没有改变，也就是二者抵消后的结果。</p>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记(一)——方程组的几何解释</title>
    <link href="/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%B8%80)%E2%80%94%E2%80%94%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E5%87%A0%E4%BD%95%E8%A7%A3%E9%87%8A/"/>
    <url>/2022/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0(%E4%B8%80)%E2%80%94%E2%80%94%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E5%87%A0%E4%BD%95%E8%A7%A3%E9%87%8A/</url>
    
    <content type="html"><![CDATA[<p>开篇第一讲主要通过线性方程组引出矩阵，并传授了如何通过<strong>行图像</strong>和<strong>列图像</strong>来分别理解矩阵的意义。最后基于列的线性组合视角来初步解答了这样的一个问题：对任意向量<spanclass="math inline">\(b\)</span>，能否求解<spanclass="math inline">\(Ax=b\)</span>。</p><span id="more"></span><h1 id="方程组的几何解释">方程组的几何解释</h1><h2 id="二元一次方程组">二元一次方程组</h2><p>方程组： <span class="math inline">\(\begin{cases}  2x&amp;-y&amp;=0\\  -x&amp;+2y&amp;=3 \end{cases}\)</span></p><p>写作矩阵形式有： <spanclass="math inline">\(\begin{bmatrix}  2&amp;-1 \\  -1&amp;2\end{bmatrix} \begin{bmatrix}  x \\  y \end{bmatrix}= \begin{bmatrix} 0\\ 3 \end{bmatrix}\)</span></p><p>第一个矩阵一般称为系数矩阵<spanclass="math inline">\(A\)</span>，第二个矩阵成为向量<spanclass="math inline">\(x\)</span>，第三个矩阵称为向量<spanclass="math inline">\(b\)</span>，线性方程组写为<spanclass="math inline">\(Ax=b\)</span>。</p><h2 id="行图像row-picture">行图像(Row picture)</h2><p>如上例，按行解读如下： - 第一行为2个x和-1个y组合成0 -第二行为-1个x和2个y组合成3</p><p>这种解读与我们此前对二元一次方程组的解读方法是一致的，我们都知道，二元一次方程组实际上就是求解二维平面两条直线的交点：<img src="2022-05-02-12-15-37.png" /></p><p>交点坐标为<span class="math inline">\((1,2)\)</span>，即<spanclass="math inline">\(x=1, y=2\)</span>为方程组的解。</p><h2 id="列图像column-picture">列图像(Column picture)</h2><p>那么，如果我们换一个视角呢？我们把矩阵<spanclass="math inline">\(A\)</span>拆成列向量，进行如下线性组合： <spanclass="math inline">\(x \begin{bmatrix}  2 \\  -1 \end{bmatrix}+y\begin{bmatrix} -1 \\ 2 \end{bmatrix}= \begin{bmatrix} 0 \\ 3\end{bmatrix}\)</span></p><p>那么就可以解读为<span class="math inline">\(x\)</span>个<spanclass="math inline">\(col_1\)</span>和<spanclass="math inline">\(y\)</span>个<spanclass="math inline">\(col_2\)</span>的组合，其中<spanclass="math inline">\(\begin{bmatrix}2\\-1\end{bmatrix}\)</span>称为<spanclass="math inline">\(col_1\)</span>，<spanclass="math inline">\(\begin{bmatrix}-1\\2\end{bmatrix}\)</span>称为<spanclass="math inline">\(col_2\)</span>。</p><p>肉眼观察就可以看出，需要1个<spanclass="math inline">\(col_1\)</span>和2个<spanclass="math inline">\(col_2\)</span>，组合起来就可以变成<spanclass="math inline">\(\begin{bmatrix}0\\3\end{bmatrix}\)</span>。因此同样得出<spanclass="math inline">\(x=1, y=2\)</span>。</p><p>列向量相加的几何意义： <img src="2022-05-02-13-01-08.png" /></p><p>绿向量<span class="math inline">\(col_1\)</span>与蓝向量<spanclass="math inline">\(col_2\)</span>相加，按照平行四边形法则，合成的就是红向量<spanclass="math inline">\(b\)</span>。</p><p>进一步思考<span class="math inline">\(col_1\)</span>和<spanclass="math inline">\(col_2\)</span>的所有线性组合能够得到什么呢？显然它们可以铺满整个二维平面。那么<spanclass="math inline">\(Ax=b\)</span>如果按照列的线性组合来看，<strong>求解<spanclass="math inline">\(Ax=b\)</span>实际上就是在问询对于给定的<spanclass="math inline">\(b\)</span>，是否能够找到一种组合方式来让<spanclass="math inline">\(A\)</span>中各列向量<spanclass="math inline">\(col_i\)</span>可以组合成列向量<spanclass="math inline">\(b\)</span>。</strong></p><h2 id="三元一次方程组">三元一次方程组</h2><p><span class="math inline">\(\begin{cases}  2x&amp;-y&amp;&amp;=0\\  -x&amp;+2y&amp;-z&amp;=-1 \\  &amp;-3y&amp;+4z&amp;=4\end{cases}\)</span></p><p>写作矩阵形式： <span class="math inline">\(A=\begin{bmatrix}2&amp;-1&amp;0 \\ -1&amp;2&amp;-1 \\ 0&amp;-3&amp;4\end{bmatrix}\)</span>,<span class="math inline">\(b=\begin{bmatrix} 0\\ -1 \\ 4 \end{bmatrix}\)</span></p><p>如果按行图像来思考：三维直角坐标系中，每个方程都将确定一个平面，三个平面会相交于一点，该点即为方程组的解。</p><p>如果按列图像来思考，拆写成： <spanclass="math inline">\(x\begin{bmatrix} 2 \\ -1 \\ 0\end{bmatrix}+y\begin{bmatrix} -1 \\  2 \\-3\end{bmatrix}+z\begin{bmatrix} 0 \\ -1 \\4\end{bmatrix}=\begin{bmatrix} 0 \\ -1 \\ 4\end{bmatrix}\)</span></p><p>也就是<span class="math inline">\(x\)</span>个<spanclass="math inline">\(col_1\)</span>，<spanclass="math inline">\(y\)</span>个<spanclass="math inline">\(col_2\)</span>和<spanclass="math inline">\(z\)</span>个<spanclass="math inline">\(col_3\)</span>线性组合成列向量<spanclass="math inline">\(b\)</span>。通过列视角来看这个方程组的解非常显然，只需要<spanclass="math inline">\(x=0,y=0,z=1\)</span>即可满足（<spanclass="math inline">\(z\)</span>刚好等于<spanclass="math inline">\(b\)</span>），而从行视角来看就没有那么一目了然。</p><blockquote><p>当然了，这是精心构造的一组例子，并不是说列视角就比行视角优越，只是培养列视角分析问题的sense对线性代数这门课（我觉着更像一门语言）来说非常重要。</p></blockquote><p>那么问题又回来了，对于任意<spanclass="math inline">\(b\)</span>，是否都能求解<spanclass="math inline">\(Ax=b\)</span>呢？用列向量视角来说，就是<spanclass="math inline">\(col_1,col_2,col_3\)</span>三个列向量的线性组合是否可以填满整个三维坐标系？对上例来说，答案是肯定的。因为实际上这个<spanclass="math inline">\(A\)</span>矩阵是个<strong>非奇异矩阵、可逆矩阵</strong>（后续课程会讲到），对于任意的列向量<spanclass="math inline">\(b\)</span>，它总是有解的。</p><p>那么在什么情况下，三个列向量的组合得不到所有的<spanclass="math inline">\(b\)</span>呢？试想这样一种情况：三个列向量在同一平面，那么无论它们如何组合，产生的列向量也一定在该平面上，因此，对于不在该平面的列向量<spanclass="math inline">\(b\)</span>，方程组就是无解的。后续课程会学习到这种情况叫做<strong>奇异矩阵、不可逆矩阵</strong>。</p><p>人类的大脑是三维的，所以四维以上的空间是无法具象化的，但是我们从二维到三维，和从三维到更高维的过程实际上并没有什么差别，因此，通过列视角的线性组合，哪怕是100维的向量，思考与处理也如法炮制。</p>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT-18.06-linear_algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>楔子</title>
    <link href="/2022/05/01/%E6%A5%94%E5%AD%90/"/>
    <url>/2022/05/01/%E6%A5%94%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<p>上次折腾博客还是醉心于binarysecurity的时节，如今却是弃之如敝履。彼时彼刻，正如此时此刻，何移之速也！</p><p>互联网变化之快让人越来越浮躁，工作越久、越难以静下心来去专研某个领域的知识，不学无术就愈发膨胀，一点点丧失核心竞争力，最后与前沿脱轨，熬成药渣，泄入深渊。我不知道一个人应该如何消化掉鸡飞蛋打、毫无成就的日常工作的挫败感和996福报带来的身心俱疲，只是入行这么多年，的的确确是弄丢了意气风发、快意恩仇，满脑子想的尽是冠冕堂皇的不粘锅、踢皮球，冰与火，周旋久。</p><span id="more"></span><p>用如今的流行梗来说：小僧没有那种世俗的欲望。“举世誉之而不加劝，举世非之而不加沮。不以物喜，不以己悲。”秉承着这样的人生信条，靠物我两忘屏蔽了职场所有的画饼和PUA，也接受了“是岁年大旱，衢州人食人”的魔幻与惨案，甚至乐在其中。坦白来说，我不红眼那些蹭上时代红利的既得利益者，也不在乎能不能坐上位高权重的玉座，毕生所求不过自由，而自由其实并不意味着“想做什么就可以做什么”，而是“不想做什么，就可以不做”。壁立千仞，无欲则刚。</p><p>这么多年过去，扪心自问这一身本领从何而来，只道是“年少轻狂不服气，万千道法书中藏。穷经皓首等闲事，千锤百炼证沧桑。”算来前前后后，一共经历了三重心境上的变化：</p><ol type="1"><li>待到秋来九月八，我花开后百花杀：以前觉着自己得天独厚，是故事的主角，只要是自己想做的，一定可以做到最好。因此接受不了自己的平庸，拼尽全力证明自己。</li><li>横看成岭侧成峰，远近高低各不同：几经挫折后发现人确实有不同的天赋，我要找到自己擅长的领域，做到最好；不擅长的东西不要强求。</li><li>沉舟侧畔千帆过，病树前头万木春：终于认识到人与人的差距比人与狗的差距还大，强中自有强中手，一山更比一山高，逐渐接受了自己的平庸，与自己妥协，但心意却更加坚定。</li></ol><p>当认识到自己是一个废物的时候，就再也没有包袱了：没有必要和别人比较，我只想看看自己的天花板有多高。遂重整旗鼓，勤将劝勉，闭关清修……这回必定给大伙整个好活~</p><p>千头万绪，百感交集，不知从何说起，唯愿顺其自然，一切随缘。飘蓬入海沉浮定，马齿徒增未可知。</p><p align="right">by 玉涵，写于2022年5月1日深夜，雨</p>]]></content>
    
    
    <categories>
      
      <category>杂感</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
